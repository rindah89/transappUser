(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Utilities for creating WebSocket instances across runtimes.
 */ __turbopack_context__.s([
    "WebSocketFactory",
    ()=>WebSocketFactory,
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_class_call_check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_create_class.js [app-client] (ecmascript)");
;
;
var WebSocketFactory = /*#__PURE__*/ function() {
    "use strict";
    function WebSocketFactory() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, WebSocketFactory);
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(WebSocketFactory, null, [
        {
            key: "detectEnvironment",
            value: function detectEnvironment() {
                var _a;
                if (typeof WebSocket !== 'undefined') {
                    return {
                        type: 'native',
                        constructor: WebSocket
                    };
                }
                if (typeof globalThis !== 'undefined' && typeof globalThis.WebSocket !== 'undefined') {
                    return {
                        type: 'native',
                        constructor: globalThis.WebSocket
                    };
                }
                if (("TURBOPACK compile-time value", "object") !== 'undefined' && typeof /*TURBOPACK member replacement*/ __turbopack_context__.g.WebSocket !== 'undefined') {
                    return {
                        type: 'native',
                        constructor: /*TURBOPACK member replacement*/ __turbopack_context__.g.WebSocket
                    };
                }
                if (typeof globalThis !== 'undefined' && typeof globalThis.WebSocketPair !== 'undefined' && typeof globalThis.WebSocket === 'undefined') {
                    return {
                        type: 'cloudflare',
                        error: 'Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.',
                        workaround: 'Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime.'
                    };
                }
                if (typeof globalThis !== 'undefined' && globalThis.EdgeRuntime || typeof navigator !== 'undefined' && ((_a = navigator.userAgent) === null || _a === void 0 ? void 0 : _a.includes('Vercel-Edge'))) {
                    return {
                        type: 'unsupported',
                        error: 'Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.',
                        workaround: 'Use serverless functions or a different deployment target for WebSocket functionality.'
                    };
                }
                if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined') {
                    // Use dynamic property access to avoid Next.js Edge Runtime static analysis warnings
                    var processVersions = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]['versions'];
                    if (processVersions && processVersions['node']) {
                        // Remove 'v' prefix if present and parse the major version
                        var versionString = processVersions['node'];
                        var nodeVersion = parseInt(versionString.replace(/^v/, '').split('.')[0]);
                        // Node.js 22+ should have native WebSocket
                        if (nodeVersion >= 22) {
                            // Check if native WebSocket is available (should be in Node.js 22+)
                            if (typeof globalThis.WebSocket !== 'undefined') {
                                return {
                                    type: 'native',
                                    constructor: globalThis.WebSocket
                                };
                            }
                            // If not available, user needs to provide it
                            return {
                                type: 'unsupported',
                                error: "Node.js ".concat(nodeVersion, " detected but native WebSocket not found."),
                                workaround: 'Provide a WebSocket implementation via the transport option.'
                            };
                        }
                        // Node.js < 22 doesn't have native WebSocket
                        return {
                            type: 'unsupported',
                            error: "Node.js ".concat(nodeVersion, " detected without native WebSocket support."),
                            workaround: 'For Node.js < 22, install "ws" package and provide it via the transport option:\n' + 'import ws from "ws"\n' + 'new RealtimeClient(url, { transport: ws })'
                        };
                    }
                }
                return {
                    type: 'unsupported',
                    error: 'Unknown JavaScript runtime without WebSocket support.',
                    workaround: "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."
                };
            }
        },
        {
            key: "getWebSocketConstructor",
            value: /**
     * Returns the best available WebSocket constructor for the current runtime.
     *
     * @example
     * ```ts
     * const WS = WebSocketFactory.getWebSocketConstructor()
     * const socket = new WS('wss://realtime.supabase.co/socket')
     * ```
     */ function getWebSocketConstructor() {
                var env = this.detectEnvironment();
                if (env.constructor) {
                    return env.constructor;
                }
                var errorMessage = env.error || 'WebSocket not supported in this environment.';
                if (env.workaround) {
                    errorMessage += "\n\nSuggested solution: ".concat(env.workaround);
                }
                throw new Error(errorMessage);
            }
        },
        {
            key: "createWebSocket",
            value: /**
     * Creates a WebSocket using the detected constructor.
     *
     * @example
     * ```ts
     * const socket = WebSocketFactory.createWebSocket('wss://realtime.supabase.co/socket')
     * ```
     */ function createWebSocket(url, protocols) {
                var WS = this.getWebSocketConstructor();
                return new WS(url, protocols);
            }
        },
        {
            key: "isWebSocketSupported",
            value: /**
     * Detects whether the runtime can establish WebSocket connections.
     *
     * @example
     * ```ts
     * if (!WebSocketFactory.isWebSocketSupported()) {
     *   console.warn('Falling back to long polling')
     * }
     * ```
     */ function isWebSocketSupported() {
                try {
                    var env = this.detectEnvironment();
                    return env.type === 'native' || env.type === 'ws';
                } catch (_a) {
                    return false;
                }
            }
        }
    ]);
    return WebSocketFactory;
}();
const __TURBOPACK__default__export__ = WebSocketFactory;
 //# sourceMappingURL=websocket-factory.js.map
}),
"[project]/node_modules/@supabase/realtime-js/dist/module/lib/version.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Generated automatically during releases by scripts/update-version-files.ts
// This file provides runtime access to the package version for:
// - HTTP request headers (e.g., X-Client-Info header for API requests)
// - Debugging and support (identifying which version is running)
// - Telemetry and logging (version reporting in errors/analytics)
// - Ensuring build artifacts match the published package version
__turbopack_context__.s([
    "version",
    ()=>version
]);
var version = '2.87.1'; //# sourceMappingURL=version.js.map
}),
"[project]/node_modules/@supabase/realtime-js/dist/module/lib/constants.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CHANNEL_EVENTS",
    ()=>CHANNEL_EVENTS,
    "CHANNEL_STATES",
    ()=>CHANNEL_STATES,
    "CONNECTION_STATE",
    ()=>CONNECTION_STATE,
    "DEFAULT_TIMEOUT",
    ()=>DEFAULT_TIMEOUT,
    "DEFAULT_VERSION",
    ()=>DEFAULT_VERSION,
    "DEFAULT_VSN",
    ()=>DEFAULT_VSN,
    "MAX_PUSH_BUFFER_SIZE",
    ()=>MAX_PUSH_BUFFER_SIZE,
    "SOCKET_STATES",
    ()=>SOCKET_STATES,
    "TRANSPORTS",
    ()=>TRANSPORTS,
    "VERSION",
    ()=>VERSION,
    "VSN_1_0_0",
    ()=>VSN_1_0_0,
    "VSN_2_0_0",
    ()=>VSN_2_0_0,
    "WS_CLOSE_NORMAL",
    ()=>WS_CLOSE_NORMAL
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/lib/version.js [app-client] (ecmascript)");
;
var DEFAULT_VERSION = "realtime-js/".concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"]);
var VSN_1_0_0 = '1.0.0';
var VSN_2_0_0 = '2.0.0';
var DEFAULT_VSN = VSN_1_0_0;
var VERSION = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["version"];
var DEFAULT_TIMEOUT = 10000;
var WS_CLOSE_NORMAL = 1000;
var MAX_PUSH_BUFFER_SIZE = 100;
var SOCKET_STATES;
(function(SOCKET_STATES) {
    SOCKET_STATES[SOCKET_STATES["connecting"] = 0] = "connecting";
    SOCKET_STATES[SOCKET_STATES["open"] = 1] = "open";
    SOCKET_STATES[SOCKET_STATES["closing"] = 2] = "closing";
    SOCKET_STATES[SOCKET_STATES["closed"] = 3] = "closed";
})(SOCKET_STATES || (SOCKET_STATES = {}));
var CHANNEL_STATES;
(function(CHANNEL_STATES) {
    CHANNEL_STATES["closed"] = "closed";
    CHANNEL_STATES["errored"] = "errored";
    CHANNEL_STATES["joined"] = "joined";
    CHANNEL_STATES["joining"] = "joining";
    CHANNEL_STATES["leaving"] = "leaving";
})(CHANNEL_STATES || (CHANNEL_STATES = {}));
var CHANNEL_EVENTS;
(function(CHANNEL_EVENTS) {
    CHANNEL_EVENTS["close"] = "phx_close";
    CHANNEL_EVENTS["error"] = "phx_error";
    CHANNEL_EVENTS["join"] = "phx_join";
    CHANNEL_EVENTS["reply"] = "phx_reply";
    CHANNEL_EVENTS["leave"] = "phx_leave";
    CHANNEL_EVENTS["access_token"] = "access_token";
})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));
var TRANSPORTS;
(function(TRANSPORTS) {
    TRANSPORTS["websocket"] = "websocket";
})(TRANSPORTS || (TRANSPORTS = {}));
var CONNECTION_STATE;
(function(CONNECTION_STATE) {
    CONNECTION_STATE["Connecting"] = "connecting";
    CONNECTION_STATE["Open"] = "open";
    CONNECTION_STATE["Closing"] = "closing";
    CONNECTION_STATE["Closed"] = "closed";
})(CONNECTION_STATE || (CONNECTION_STATE = {})); //# sourceMappingURL=constants.js.map
}),
"[project]/node_modules/@supabase/realtime-js/dist/module/lib/serializer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>Serializer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_class_call_check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_create_class.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_instanceof.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_sliced_to_array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_type_of.js [app-client] (ecmascript)");
;
;
;
;
;
var Serializer = /*#__PURE__*/ function() {
    "use strict";
    function Serializer(allowedMetadataKeys) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, Serializer);
        this.HEADER_LENGTH = 1;
        this.USER_BROADCAST_PUSH_META_LENGTH = 6;
        this.KINDS = {
            userBroadcastPush: 3,
            userBroadcast: 4
        };
        this.BINARY_ENCODING = 0;
        this.JSON_ENCODING = 1;
        this.BROADCAST_EVENT = 'broadcast';
        this.allowedMetadataKeys = [];
        this.allowedMetadataKeys = allowedMetadataKeys !== null && allowedMetadataKeys !== void 0 ? allowedMetadataKeys : [];
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(Serializer, [
        {
            key: "encode",
            value: function encode(msg, callback) {
                if (msg.event === this.BROADCAST_EVENT && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(msg.payload, ArrayBuffer) && typeof msg.payload.event === 'string') {
                    return callback(this._binaryEncodeUserBroadcastPush(msg));
                }
                var payload = [
                    msg.join_ref,
                    msg.ref,
                    msg.topic,
                    msg.event,
                    msg.payload
                ];
                return callback(JSON.stringify(payload));
            }
        },
        {
            key: "_binaryEncodeUserBroadcastPush",
            value: function _binaryEncodeUserBroadcastPush(message) {
                var _a;
                if (this._isArrayBuffer((_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload)) {
                    return this._encodeBinaryUserBroadcastPush(message);
                } else {
                    return this._encodeJsonUserBroadcastPush(message);
                }
            }
        },
        {
            key: "_encodeBinaryUserBroadcastPush",
            value: function _encodeBinaryUserBroadcastPush(message) {
                var _a, _b;
                var userPayload = (_b = (_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : new ArrayBuffer(0);
                return this._encodeUserBroadcastPush(message, this.BINARY_ENCODING, userPayload);
            }
        },
        {
            key: "_encodeJsonUserBroadcastPush",
            value: function _encodeJsonUserBroadcastPush(message) {
                var _a, _b;
                var userPayload = (_b = (_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : {};
                var encoder = new TextEncoder();
                var encodedUserPayload = encoder.encode(JSON.stringify(userPayload)).buffer;
                return this._encodeUserBroadcastPush(message, this.JSON_ENCODING, encodedUserPayload);
            }
        },
        {
            key: "_encodeUserBroadcastPush",
            value: function _encodeUserBroadcastPush(message, encodingType, encodedPayload) {
                var _a, _b;
                var topic = message.topic;
                var ref = (_a = message.ref) !== null && _a !== void 0 ? _a : '';
                var joinRef = (_b = message.join_ref) !== null && _b !== void 0 ? _b : '';
                var userEvent = message.payload.event;
                // Filter metadata based on allowed keys
                var rest = this.allowedMetadataKeys ? this._pick(message.payload, this.allowedMetadataKeys) : {};
                var metadata = Object.keys(rest).length === 0 ? '' : JSON.stringify(rest);
                // Validate lengths don't exceed uint8 max value (255)
                if (joinRef.length > 255) {
                    throw new Error("joinRef length ".concat(joinRef.length, " exceeds maximum of 255"));
                }
                if (ref.length > 255) {
                    throw new Error("ref length ".concat(ref.length, " exceeds maximum of 255"));
                }
                if (topic.length > 255) {
                    throw new Error("topic length ".concat(topic.length, " exceeds maximum of 255"));
                }
                if (userEvent.length > 255) {
                    throw new Error("userEvent length ".concat(userEvent.length, " exceeds maximum of 255"));
                }
                if (metadata.length > 255) {
                    throw new Error("metadata length ".concat(metadata.length, " exceeds maximum of 255"));
                }
                var metaLength = this.USER_BROADCAST_PUSH_META_LENGTH + joinRef.length + ref.length + topic.length + userEvent.length + metadata.length;
                var header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
                var view = new DataView(header);
                var offset = 0;
                view.setUint8(offset++, this.KINDS.userBroadcastPush); // kind
                view.setUint8(offset++, joinRef.length);
                view.setUint8(offset++, ref.length);
                view.setUint8(offset++, topic.length);
                view.setUint8(offset++, userEvent.length);
                view.setUint8(offset++, metadata.length);
                view.setUint8(offset++, encodingType);
                Array.from(joinRef, function(_char) {
                    return view.setUint8(offset++, _char.charCodeAt(0));
                });
                Array.from(ref, function(_char) {
                    return view.setUint8(offset++, _char.charCodeAt(0));
                });
                Array.from(topic, function(_char) {
                    return view.setUint8(offset++, _char.charCodeAt(0));
                });
                Array.from(userEvent, function(_char) {
                    return view.setUint8(offset++, _char.charCodeAt(0));
                });
                Array.from(metadata, function(_char) {
                    return view.setUint8(offset++, _char.charCodeAt(0));
                });
                var combined = new Uint8Array(header.byteLength + encodedPayload.byteLength);
                combined.set(new Uint8Array(header), 0);
                combined.set(new Uint8Array(encodedPayload), header.byteLength);
                return combined.buffer;
            }
        },
        {
            key: "decode",
            value: function decode(rawPayload, callback) {
                if (this._isArrayBuffer(rawPayload)) {
                    var result = this._binaryDecode(rawPayload);
                    return callback(result);
                }
                if (typeof rawPayload === 'string') {
                    var jsonPayload = JSON.parse(rawPayload);
                    var _jsonPayload = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(jsonPayload, 5), join_ref = _jsonPayload[0], ref = _jsonPayload[1], topic = _jsonPayload[2], event = _jsonPayload[3], payload = _jsonPayload[4];
                    return callback({
                        join_ref: join_ref,
                        ref: ref,
                        topic: topic,
                        event: event,
                        payload: payload
                    });
                }
                return callback({});
            }
        },
        {
            key: "_binaryDecode",
            value: function _binaryDecode(buffer) {
                var view = new DataView(buffer);
                var kind = view.getUint8(0);
                var decoder = new TextDecoder();
                switch(kind){
                    case this.KINDS.userBroadcast:
                        return this._decodeUserBroadcast(buffer, view, decoder);
                }
            }
        },
        {
            key: "_decodeUserBroadcast",
            value: function _decodeUserBroadcast(buffer, view, decoder) {
                var topicSize = view.getUint8(1);
                var userEventSize = view.getUint8(2);
                var metadataSize = view.getUint8(3);
                var payloadEncoding = view.getUint8(4);
                var offset = this.HEADER_LENGTH + 4;
                var topic = decoder.decode(buffer.slice(offset, offset + topicSize));
                offset = offset + topicSize;
                var userEvent = decoder.decode(buffer.slice(offset, offset + userEventSize));
                offset = offset + userEventSize;
                var metadata = decoder.decode(buffer.slice(offset, offset + metadataSize));
                offset = offset + metadataSize;
                var payload = buffer.slice(offset, buffer.byteLength);
                var parsedPayload = payloadEncoding === this.JSON_ENCODING ? JSON.parse(decoder.decode(payload)) : payload;
                var data = {
                    type: this.BROADCAST_EVENT,
                    event: userEvent,
                    payload: parsedPayload
                };
                // Metadata is optional and always JSON encoded
                if (metadataSize > 0) {
                    data['meta'] = JSON.parse(metadata);
                }
                return {
                    join_ref: null,
                    ref: null,
                    topic: topic,
                    event: this.BROADCAST_EVENT,
                    payload: data
                };
            }
        },
        {
            key: "_isArrayBuffer",
            value: function _isArrayBuffer(buffer) {
                var _a;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(buffer, ArrayBuffer) || ((_a = buffer === null || buffer === void 0 ? void 0 : buffer.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'ArrayBuffer';
            }
        },
        {
            key: "_pick",
            value: function _pick(obj, keys) {
                if (!obj || (typeof obj === "undefined" ? "undefined" : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(obj)) !== 'object') {
                    return {};
                }
                return Object.fromEntries(Object.entries(obj).filter(function(param) {
                    var _param = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(param, 1), key = _param[0];
                    return keys.includes(key);
                }));
            }
        }
    ]);
    return Serializer;
} //# sourceMappingURL=serializer.js.map
();
;
}),
"[project]/node_modules/@supabase/realtime-js/dist/module/lib/timer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.
 *
 * @example
 *    let reconnectTimer = new Timer(() => this.connect(), function(tries){
 *      return [1000, 5000, 10000][tries - 1] || 10000
 *    })
 *    reconnectTimer.scheduleTimeout() // fires after 1000
 *    reconnectTimer.scheduleTimeout() // fires after 5000
 *    reconnectTimer.reset()
 *    reconnectTimer.scheduleTimeout() // fires after 1000
 */ __turbopack_context__.s([
    "default",
    ()=>Timer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_class_call_check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_create_class.js [app-client] (ecmascript)");
;
;
var Timer = /*#__PURE__*/ function() {
    "use strict";
    function Timer(callback, timerCalc) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, Timer);
        this.callback = callback;
        this.timerCalc = timerCalc;
        this.timer = undefined;
        this.tries = 0;
        this.callback = callback;
        this.timerCalc = timerCalc;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(Timer, [
        {
            key: "reset",
            value: function reset() {
                this.tries = 0;
                clearTimeout(this.timer);
                this.timer = undefined;
            }
        },
        {
            // Cancels any previous scheduleTimeout and schedules callback
            key: "scheduleTimeout",
            value: function scheduleTimeout() {
                var _this = this;
                clearTimeout(this.timer);
                this.timer = setTimeout(function() {
                    _this.tries = _this.tries + 1;
                    _this.callback();
                }, this.timerCalc(this.tries + 1));
            }
        }
    ]);
    return Timer;
} //# sourceMappingURL=timer.js.map
();
;
}),
"[project]/node_modules/@supabase/realtime-js/dist/module/lib/transformers.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Helpers to convert the change Payload into native JS types.
 */ // Adapted from epgsql (src/epgsql_binary.erl), this module licensed under
// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE
__turbopack_context__.s([
    "PostgresTypes",
    ()=>PostgresTypes,
    "convertCell",
    ()=>convertCell,
    "convertChangeData",
    ()=>convertChangeData,
    "convertColumn",
    ()=>convertColumn,
    "httpEndpointURL",
    ()=>httpEndpointURL,
    "toArray",
    ()=>toArray,
    "toBoolean",
    ()=>toBoolean,
    "toJson",
    ()=>toJson,
    "toNumber",
    ()=>toNumber,
    "toTimestampString",
    ()=>toTimestampString
]);
var PostgresTypes;
(function(PostgresTypes) {
    PostgresTypes["abstime"] = "abstime";
    PostgresTypes["bool"] = "bool";
    PostgresTypes["date"] = "date";
    PostgresTypes["daterange"] = "daterange";
    PostgresTypes["float4"] = "float4";
    PostgresTypes["float8"] = "float8";
    PostgresTypes["int2"] = "int2";
    PostgresTypes["int4"] = "int4";
    PostgresTypes["int4range"] = "int4range";
    PostgresTypes["int8"] = "int8";
    PostgresTypes["int8range"] = "int8range";
    PostgresTypes["json"] = "json";
    PostgresTypes["jsonb"] = "jsonb";
    PostgresTypes["money"] = "money";
    PostgresTypes["numeric"] = "numeric";
    PostgresTypes["oid"] = "oid";
    PostgresTypes["reltime"] = "reltime";
    PostgresTypes["text"] = "text";
    PostgresTypes["time"] = "time";
    PostgresTypes["timestamp"] = "timestamp";
    PostgresTypes["timestamptz"] = "timestamptz";
    PostgresTypes["timetz"] = "timetz";
    PostgresTypes["tsrange"] = "tsrange";
    PostgresTypes["tstzrange"] = "tstzrange";
})(PostgresTypes || (PostgresTypes = {}));
var convertChangeData = function(columns, record) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var _a;
    var skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];
    if (!record) {
        return {};
    }
    return Object.keys(record).reduce(function(acc, rec_key) {
        acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);
        return acc;
    }, {});
};
var convertColumn = function(columnName, columns, record, skipTypes) {
    var column = columns.find(function(x) {
        return x.name === columnName;
    });
    var colType = column === null || column === void 0 ? void 0 : column.type;
    var value = record[columnName];
    if (colType && !skipTypes.includes(colType)) {
        return convertCell(colType, value);
    }
    return noop(value);
};
var convertCell = function(type, value) {
    // if data type is an array
    if (type.charAt(0) === '_') {
        var dataType = type.slice(1, type.length);
        return toArray(value, dataType);
    }
    // If not null, convert to correct type.
    switch(type){
        case PostgresTypes.bool:
            return toBoolean(value);
        case PostgresTypes.float4:
        case PostgresTypes.float8:
        case PostgresTypes.int2:
        case PostgresTypes.int4:
        case PostgresTypes.int8:
        case PostgresTypes.numeric:
        case PostgresTypes.oid:
            return toNumber(value);
        case PostgresTypes.json:
        case PostgresTypes.jsonb:
            return toJson(value);
        case PostgresTypes.timestamp:
            return toTimestampString(value); // Format to be consistent with PostgREST
        case PostgresTypes.abstime:
        case PostgresTypes.date:
        case PostgresTypes.daterange:
        case PostgresTypes.int4range:
        case PostgresTypes.int8range:
        case PostgresTypes.money:
        case PostgresTypes.reltime:
        case PostgresTypes.text:
        case PostgresTypes.time:
        case PostgresTypes.timestamptz:
        case PostgresTypes.timetz:
        case PostgresTypes.tsrange:
        case PostgresTypes.tstzrange:
            return noop(value);
        default:
            // Return the value for remaining types
            return noop(value);
    }
};
var noop = function(value) {
    return value;
};
var toBoolean = function(value) {
    switch(value){
        case 't':
            return true;
        case 'f':
            return false;
        default:
            return value;
    }
};
var toNumber = function(value) {
    if (typeof value === 'string') {
        var parsedValue = parseFloat(value);
        if (!Number.isNaN(parsedValue)) {
            return parsedValue;
        }
    }
    return value;
};
var toJson = function(value) {
    if (typeof value === 'string') {
        try {
            return JSON.parse(value);
        } catch (error) {
            console.log("JSON parse error: ".concat(error));
            return value;
        }
    }
    return value;
};
var toArray = function(value, type) {
    if (typeof value !== 'string') {
        return value;
    }
    var lastIdx = value.length - 1;
    var closeBrace = value[lastIdx];
    var openBrace = value[0];
    // Confirm value is a Postgres array by checking curly brackets
    if (openBrace === '{' && closeBrace === '}') {
        var arr;
        var valTrim = value.slice(1, lastIdx);
        // TODO: find a better solution to separate Postgres array data
        try {
            arr = JSON.parse('[' + valTrim + ']');
        } catch (_) {
            // WARNING: splitting on comma does not cover all edge cases
            arr = valTrim ? valTrim.split(',') : [];
        }
        return arr.map(function(val) {
            return convertCell(type, val);
        });
    }
    return value;
};
var toTimestampString = function(value) {
    if (typeof value === 'string') {
        return value.replace(' ', 'T');
    }
    return value;
};
var httpEndpointURL = function(socketUrl) {
    var wsUrl = new URL(socketUrl);
    wsUrl.protocol = wsUrl.protocol.replace(/^ws/i, 'http');
    wsUrl.pathname = wsUrl.pathname.replace(/\/+$/, '') // remove all trailing slashes
    .replace(/\/socket\/websocket$/i, '') // remove the socket/websocket path
    .replace(/\/socket$/i, '') // remove the socket path
    .replace(/\/websocket$/i, ''); // remove the websocket path
    if (wsUrl.pathname === '' || wsUrl.pathname === '/') {
        wsUrl.pathname = '/api/broadcast';
    } else {
        wsUrl.pathname = wsUrl.pathname + '/api/broadcast';
    }
    return wsUrl.href;
}; //# sourceMappingURL=transformers.js.map
}),
"[project]/node_modules/@supabase/realtime-js/dist/module/lib/push.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>Push
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_class_call_check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_create_class.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/lib/constants.js [app-client] (ecmascript)");
;
;
;
var Push = /*#__PURE__*/ function() {
    "use strict";
    function Push(channel, event) {
        var payload = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, timeout = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_TIMEOUT"];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, Push);
        this.channel = channel;
        this.event = event;
        this.payload = payload;
        this.timeout = timeout;
        this.sent = false;
        this.timeoutTimer = undefined;
        this.ref = '';
        this.receivedResp = null;
        this.recHooks = [];
        this.refEvent = null;
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(Push, [
        {
            key: "resend",
            value: function resend(timeout) {
                this.timeout = timeout;
                this._cancelRefEvent();
                this.ref = '';
                this.refEvent = null;
                this.receivedResp = null;
                this.sent = false;
                this.send();
            }
        },
        {
            key: "send",
            value: function send() {
                if (this._hasReceived('timeout')) {
                    return;
                }
                this.startTimeout();
                this.sent = true;
                this.channel.socket.push({
                    topic: this.channel.topic,
                    event: this.event,
                    payload: this.payload,
                    ref: this.ref,
                    join_ref: this.channel._joinRef()
                });
            }
        },
        {
            key: "updatePayload",
            value: function updatePayload(payload) {
                this.payload = Object.assign(Object.assign({}, this.payload), payload);
            }
        },
        {
            key: "receive",
            value: function receive(status, callback) {
                var _a;
                if (this._hasReceived(status)) {
                    callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);
                }
                this.recHooks.push({
                    status: status,
                    callback: callback
                });
                return this;
            }
        },
        {
            key: "startTimeout",
            value: function startTimeout() {
                var _this = this;
                if (this.timeoutTimer) {
                    return;
                }
                this.ref = this.channel.socket._makeRef();
                this.refEvent = this.channel._replyEventName(this.ref);
                var callback = function(payload) {
                    _this._cancelRefEvent();
                    _this._cancelTimeout();
                    _this.receivedResp = payload;
                    _this._matchReceive(payload);
                };
                this.channel._on(this.refEvent, {}, callback);
                this.timeoutTimer = setTimeout(function() {
                    _this.trigger('timeout', {});
                }, this.timeout);
            }
        },
        {
            key: "trigger",
            value: function trigger(status, response) {
                if (this.refEvent) this.channel._trigger(this.refEvent, {
                    status: status,
                    response: response
                });
            }
        },
        {
            key: "destroy",
            value: function destroy() {
                this._cancelRefEvent();
                this._cancelTimeout();
            }
        },
        {
            key: "_cancelRefEvent",
            value: function _cancelRefEvent() {
                if (!this.refEvent) {
                    return;
                }
                this.channel._off(this.refEvent, {});
            }
        },
        {
            key: "_cancelTimeout",
            value: function _cancelTimeout() {
                clearTimeout(this.timeoutTimer);
                this.timeoutTimer = undefined;
            }
        },
        {
            key: "_matchReceive",
            value: function _matchReceive(param) {
                var status = param.status, response = param.response;
                this.recHooks.filter(function(h) {
                    return h.status === status;
                }).forEach(function(h) {
                    return h.callback(response);
                });
            }
        },
        {
            key: "_hasReceived",
            value: function _hasReceived(status) {
                return this.receivedResp && this.receivedResp.status === status;
            }
        }
    ]);
    return Push;
} //# sourceMappingURL=push.js.map
();
;
}),
"[project]/node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*
  This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js
  License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md
*/ __turbopack_context__.s([
    "REALTIME_PRESENCE_LISTEN_EVENTS",
    ()=>REALTIME_PRESENCE_LISTEN_EVENTS,
    "default",
    ()=>RealtimePresence
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_class_call_check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_create_class.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_to_consumable_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_to_consumable_array.js [app-client] (ecmascript)");
;
;
;
var REALTIME_PRESENCE_LISTEN_EVENTS;
(function(REALTIME_PRESENCE_LISTEN_EVENTS) {
    REALTIME_PRESENCE_LISTEN_EVENTS["SYNC"] = "sync";
    REALTIME_PRESENCE_LISTEN_EVENTS["JOIN"] = "join";
    REALTIME_PRESENCE_LISTEN_EVENTS["LEAVE"] = "leave";
})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));
var RealtimePresence = /*#__PURE__*/ function() {
    "use strict";
    function RealtimePresence(channel, opts) {
        var _this = this;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, RealtimePresence);
        this.channel = channel;
        this.state = {};
        this.pendingDiffs = [];
        this.joinRef = null;
        this.enabled = false;
        this.caller = {
            onJoin: function() {},
            onLeave: function() {},
            onSync: function() {}
        };
        var events = (opts === null || opts === void 0 ? void 0 : opts.events) || {
            state: 'presence_state',
            diff: 'presence_diff'
        };
        this.channel._on(events.state, {}, function(newState) {
            var _this_caller = _this.caller, onJoin = _this_caller.onJoin, onLeave = _this_caller.onLeave, onSync = _this_caller.onSync;
            _this.joinRef = _this.channel._joinRef();
            _this.state = RealtimePresence.syncState(_this.state, newState, onJoin, onLeave);
            _this.pendingDiffs.forEach(function(diff) {
                _this.state = RealtimePresence.syncDiff(_this.state, diff, onJoin, onLeave);
            });
            _this.pendingDiffs = [];
            onSync();
        });
        this.channel._on(events.diff, {}, function(diff) {
            var _this_caller = _this.caller, onJoin = _this_caller.onJoin, onLeave = _this_caller.onLeave, onSync = _this_caller.onSync;
            if (_this.inPendingSyncState()) {
                _this.pendingDiffs.push(diff);
            } else {
                _this.state = RealtimePresence.syncDiff(_this.state, diff, onJoin, onLeave);
                onSync();
            }
        });
        this.onJoin(function(key, currentPresences, newPresences) {
            _this.channel._trigger('presence', {
                event: 'join',
                key: key,
                currentPresences: currentPresences,
                newPresences: newPresences
            });
        });
        this.onLeave(function(key, currentPresences, leftPresences) {
            _this.channel._trigger('presence', {
                event: 'leave',
                key: key,
                currentPresences: currentPresences,
                leftPresences: leftPresences
            });
        });
        this.onSync(function() {
            _this.channel._trigger('presence', {
                event: 'sync'
            });
        });
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(RealtimePresence, [
        {
            /** @internal */ key: "onJoin",
            value: function onJoin(callback) {
                this.caller.onJoin = callback;
            }
        },
        {
            /** @internal */ key: "onLeave",
            value: function onLeave(callback) {
                this.caller.onLeave = callback;
            }
        },
        {
            /** @internal */ key: "onSync",
            value: function onSync(callback) {
                this.caller.onSync = callback;
            }
        },
        {
            /** @internal */ key: "inPendingSyncState",
            value: function inPendingSyncState() {
                return !this.joinRef || this.joinRef !== this.channel._joinRef();
            }
        }
    ], [
        {
            key: "syncState",
            value: /**
     * Used to sync the list of presences on the server with the
     * client's state.
     *
     * An optional `onJoin` and `onLeave` callback can be provided to
     * react to changes in the client's local presences across
     * disconnects and reconnects with the server.
     *
     * @internal
     */ function syncState(currentState, newState, onJoin, onLeave) {
                var state = this.cloneDeep(currentState);
                var transformedState = this.transformState(newState);
                var joins = {};
                var leaves = {};
                this.map(state, function(key, presences) {
                    if (!transformedState[key]) {
                        leaves[key] = presences;
                    }
                });
                this.map(transformedState, function(key, newPresences) {
                    var currentPresences = state[key];
                    if (currentPresences) {
                        var newPresenceRefs = newPresences.map(function(m) {
                            return m.presence_ref;
                        });
                        var curPresenceRefs = currentPresences.map(function(m) {
                            return m.presence_ref;
                        });
                        var joinedPresences = newPresences.filter(function(m) {
                            return curPresenceRefs.indexOf(m.presence_ref) < 0;
                        });
                        var leftPresences = currentPresences.filter(function(m) {
                            return newPresenceRefs.indexOf(m.presence_ref) < 0;
                        });
                        if (joinedPresences.length > 0) {
                            joins[key] = joinedPresences;
                        }
                        if (leftPresences.length > 0) {
                            leaves[key] = leftPresences;
                        }
                    } else {
                        joins[key] = newPresences;
                    }
                });
                return this.syncDiff(state, {
                    joins: joins,
                    leaves: leaves
                }, onJoin, onLeave);
            }
        },
        {
            key: "syncDiff",
            value: /**
     * Used to sync a diff of presence join and leave events from the
     * server, as they happen.
     *
     * Like `syncState`, `syncDiff` accepts optional `onJoin` and
     * `onLeave` callbacks to react to a user joining or leaving from a
     * device.
     *
     * @internal
     */ function syncDiff(state, diff, onJoin, onLeave) {
                var _this = this;
                var _ref = {
                    joins: this.transformState(diff.joins),
                    leaves: this.transformState(diff.leaves)
                }, joins = _ref.joins, leaves = _ref.leaves;
                if (!onJoin) {
                    onJoin = function() {};
                }
                if (!onLeave) {
                    onLeave = function() {};
                }
                this.map(joins, function(key, newPresences) {
                    var _a;
                    var currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];
                    state[key] = _this.cloneDeep(newPresences);
                    if (currentPresences.length > 0) {
                        var _state_key;
                        var joinedPresenceRefs = state[key].map(function(m) {
                            return m.presence_ref;
                        });
                        var curPresences = currentPresences.filter(function(m) {
                            return joinedPresenceRefs.indexOf(m.presence_ref) < 0;
                        });
                        (_state_key = state[key]).unshift.apply(_state_key, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_to_consumable_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(curPresences));
                    }
                    onJoin(key, currentPresences, newPresences);
                });
                this.map(leaves, function(key, leftPresences) {
                    var currentPresences = state[key];
                    if (!currentPresences) return;
                    var presenceRefsToRemove = leftPresences.map(function(m) {
                        return m.presence_ref;
                    });
                    currentPresences = currentPresences.filter(function(m) {
                        return presenceRefsToRemove.indexOf(m.presence_ref) < 0;
                    });
                    state[key] = currentPresences;
                    onLeave(key, currentPresences, leftPresences);
                    if (currentPresences.length === 0) delete state[key];
                });
                return state;
            }
        },
        {
            key: "map",
            value: /** @internal */ function map(obj, func) {
                return Object.getOwnPropertyNames(obj).map(function(key) {
                    return func(key, obj[key]);
                });
            }
        },
        {
            key: "transformState",
            value: /**
     * Remove 'metas' key
     * Change 'phx_ref' to 'presence_ref'
     * Remove 'phx_ref' and 'phx_ref_prev'
     *
     * @example
     * // returns {
     *  abc123: [
     *    { presence_ref: '2', user_id: 1 },
     *    { presence_ref: '3', user_id: 2 }
     *  ]
     * }
     * RealtimePresence.transformState({
     *  abc123: {
     *    metas: [
     *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },
     *      { phx_ref: '3', user_id: 2 }
     *    ]
     *  }
     * })
     *
     * @internal
     */ function transformState(state) {
                state = this.cloneDeep(state);
                return Object.getOwnPropertyNames(state).reduce(function(newState, key) {
                    var presences = state[key];
                    if ('metas' in presences) {
                        newState[key] = presences.metas.map(function(presence) {
                            presence['presence_ref'] = presence['phx_ref'];
                            delete presence['phx_ref'];
                            delete presence['phx_ref_prev'];
                            return presence;
                        });
                    } else {
                        newState[key] = presences;
                    }
                    return newState;
                }, {});
            }
        },
        {
            key: "cloneDeep",
            value: /** @internal */ function cloneDeep(obj) {
                return JSON.parse(JSON.stringify(obj));
            }
        }
    ]);
    return RealtimePresence;
} //# sourceMappingURL=RealtimePresence.js.map
();
;
}),
"[project]/node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "REALTIME_CHANNEL_STATES",
    ()=>REALTIME_CHANNEL_STATES,
    "REALTIME_LISTEN_TYPES",
    ()=>REALTIME_LISTEN_TYPES,
    "REALTIME_POSTGRES_CHANGES_LISTEN_EVENT",
    ()=>REALTIME_POSTGRES_CHANGES_LISTEN_EVENT,
    "REALTIME_SUBSCRIBE_STATES",
    ()=>REALTIME_SUBSCRIBE_STATES,
    "default",
    ()=>RealtimeChannel
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_async_to_generator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_class_call_check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_create_class.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_type_of.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript) <export __generator as _>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/lib/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$push$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/lib/push.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$timer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/lib/timer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$RealtimePresence$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$transformers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/lib/transformers.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;
(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["ALL"] = "*";
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["INSERT"] = "INSERT";
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["UPDATE"] = "UPDATE";
    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["DELETE"] = "DELETE";
})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));
var REALTIME_LISTEN_TYPES;
(function(REALTIME_LISTEN_TYPES) {
    REALTIME_LISTEN_TYPES["BROADCAST"] = "broadcast";
    REALTIME_LISTEN_TYPES["PRESENCE"] = "presence";
    REALTIME_LISTEN_TYPES["POSTGRES_CHANGES"] = "postgres_changes";
    REALTIME_LISTEN_TYPES["SYSTEM"] = "system";
})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));
var REALTIME_SUBSCRIBE_STATES;
(function(REALTIME_SUBSCRIBE_STATES) {
    REALTIME_SUBSCRIBE_STATES["SUBSCRIBED"] = "SUBSCRIBED";
    REALTIME_SUBSCRIBE_STATES["TIMED_OUT"] = "TIMED_OUT";
    REALTIME_SUBSCRIBE_STATES["CLOSED"] = "CLOSED";
    REALTIME_SUBSCRIBE_STATES["CHANNEL_ERROR"] = "CHANNEL_ERROR";
})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));
var REALTIME_CHANNEL_STATES = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_STATES"];
var RealtimeChannel = /*#__PURE__*/ function() {
    "use strict";
    function RealtimeChannel(/** Topic name can be any string. */ topic) {
        var _this = this;
        var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            config: {}
        }, socket = arguments.length > 2 ? arguments[2] : void 0;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, RealtimeChannel);
        var _a, _b;
        this.topic = topic;
        this.params = params;
        this.socket = socket;
        this.bindings = {};
        this.state = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_STATES"].closed;
        this.joinedOnce = false;
        this.pushBuffer = [];
        this.subTopic = topic.replace(/^realtime:/i, '');
        this.params.config = Object.assign({
            broadcast: {
                ack: false,
                self: false
            },
            presence: {
                key: '',
                enabled: false
            },
            private: false
        }, params.config);
        this.timeout = this.socket.timeout;
        this.joinPush = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$push$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_EVENTS"].join, this.params, this.timeout);
        this.rejoinTimer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$timer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](function() {
            return _this._rejoinUntilConnected();
        }, this.socket.reconnectAfterMs);
        this.joinPush.receive('ok', function() {
            _this.state = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_STATES"].joined;
            _this.rejoinTimer.reset();
            _this.pushBuffer.forEach(function(pushEvent) {
                return pushEvent.send();
            });
            _this.pushBuffer = [];
        });
        this._onClose(function() {
            _this.rejoinTimer.reset();
            _this.socket.log('channel', "close ".concat(_this.topic, " ").concat(_this._joinRef()));
            _this.state = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_STATES"].closed;
            _this.socket._remove(_this);
        });
        this._onError(function(reason) {
            if (_this._isLeaving() || _this._isClosed()) {
                return;
            }
            _this.socket.log('channel', "error ".concat(_this.topic), reason);
            _this.state = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_STATES"].errored;
            _this.rejoinTimer.scheduleTimeout();
        });
        this.joinPush.receive('timeout', function() {
            if (!_this._isJoining()) {
                return;
            }
            _this.socket.log('channel', "timeout ".concat(_this.topic), _this.joinPush.timeout);
            _this.state = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_STATES"].errored;
            _this.rejoinTimer.scheduleTimeout();
        });
        this.joinPush.receive('error', function(reason) {
            if (_this._isLeaving() || _this._isClosed()) {
                return;
            }
            _this.socket.log('channel', "error ".concat(_this.topic), reason);
            _this.state = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_STATES"].errored;
            _this.rejoinTimer.scheduleTimeout();
        });
        this._on(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_EVENTS"].reply, {}, function(payload, ref) {
            _this._trigger(_this._replyEventName(ref), payload);
        });
        this.presence = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$RealtimePresence$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this);
        this.broadcastEndpointURL = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$transformers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["httpEndpointURL"])(this.socket.endPoint);
        this["private"] = this.params.config["private"] || false;
        if (!this["private"] && ((_b = (_a = this.params.config) === null || _a === void 0 ? void 0 : _a.broadcast) === null || _b === void 0 ? void 0 : _b.replay)) {
            throw "tried to use replay on public channel '".concat(this.topic, "'. It must be a private channel.");
        }
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(RealtimeChannel, [
        {
            /** Subscribe registers your client with the server */ key: "subscribe",
            value: function subscribe(callback) {
                var _this = this;
                var timeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.timeout;
                var _a, _b, _c;
                if (!this.socket.isConnected()) {
                    this.socket.connect();
                }
                if (this.state == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_STATES"].closed) {
                    var _this_params = this.params, _this_params_config = _this_params.config, broadcast = _this_params_config.broadcast, presence = _this_params_config.presence, isPrivate = _this_params_config["private"];
                    var postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map(function(r) {
                        return r.filter;
                    })) !== null && _b !== void 0 ? _b : [];
                    var presence_enabled = !!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] && this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0 || ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;
                    var accessTokenPayload = {};
                    var config = {
                        broadcast: broadcast,
                        presence: Object.assign(Object.assign({}, presence), {
                            enabled: presence_enabled
                        }),
                        postgres_changes: postgres_changes,
                        private: isPrivate
                    };
                    if (this.socket.accessTokenValue) {
                        accessTokenPayload.access_token = this.socket.accessTokenValue;
                    }
                    this._onError(function(e) {
                        return callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e);
                    });
                    this._onClose(function() {
                        return callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED);
                    });
                    this.updateJoinPayload(Object.assign({
                        config: config
                    }, accessTokenPayload));
                    this.joinedOnce = true;
                    this._rejoin(timeout);
                    this.joinPush.receive('ok', function(param) {
                        var postgres_changes = param.postgres_changes;
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function() {
                            var _a, clientPostgresBindings, bindingsLen, newPostgresBindings, i, clientPostgresBinding, _clientPostgresBinding_filter, event, schema, table, filter, serverPostgresFilter;
                            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                                // Only refresh auth if using callback-based tokens
                                if (!this.socket._isManualToken()) {
                                    this.socket.setAuth();
                                }
                                if (postgres_changes === undefined) {
                                    callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
                                    return [
                                        2
                                    ];
                                } else {
                                    clientPostgresBindings = this.bindings.postgres_changes;
                                    bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;
                                    newPostgresBindings = [];
                                    for(i = 0; i < bindingsLen; i++){
                                        clientPostgresBinding = clientPostgresBindings[i];
                                        _clientPostgresBinding_filter = clientPostgresBinding.filter, event = _clientPostgresBinding_filter.event, schema = _clientPostgresBinding_filter.schema, table = _clientPostgresBinding_filter.table, filter = _clientPostgresBinding_filter.filter;
                                        serverPostgresFilter = postgres_changes && postgres_changes[i];
                                        if (serverPostgresFilter && serverPostgresFilter.event === event && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.schema, schema) && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.table, table) && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.filter, filter)) {
                                            newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {
                                                id: serverPostgresFilter.id
                                            }));
                                        } else {
                                            this.unsubscribe();
                                            this.state = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_STATES"].errored;
                                            callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error('mismatch between server and client bindings for postgres changes'));
                                            return [
                                                2
                                            ];
                                        }
                                    }
                                    this.bindings.postgres_changes = newPostgresBindings;
                                    callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
                                    return [
                                        2
                                    ];
                                }
                                //TURBOPACK unreachable
                                ;
                            });
                        }).call(_this);
                    }).receive('error', function(error) {
                        _this.state = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_STATES"].errored;
                        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));
                        return;
                    }).receive('timeout', function() {
                        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);
                        return;
                    });
                }
                return this;
            }
        },
        {
            /**
     * Returns the current presence state for this channel.
     *
     * The shape is a map keyed by presence key (for example a user id) where each entry contains the
     * tracked metadata for that user.
     */ key: "presenceState",
            value: function presenceState() {
                return this.presence.state;
            }
        },
        {
            key: "track",
            value: /**
     * Sends the supplied payload to the presence tracker so other subscribers can see that this
     * client is online. Use `untrack` to stop broadcasting presence for the same key.
     */ function track(_0) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function(payload) {
                    var opts;
                    var _arguments = arguments;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                opts = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : {};
                                return [
                                    4,
                                    this.send({
                                        type: 'presence',
                                        event: 'track',
                                        payload: payload
                                    }, opts.timeout || this.timeout)
                                ];
                            case 1:
                                return [
                                    2,
                                    _state.sent()
                                ];
                        }
                    });
                }).apply(this, arguments);
            }
        },
        {
            key: "untrack",
            value: /**
     * Removes the current presence state for this client.
     */ function untrack() {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function() {
                    var opts;
                    var _arguments = arguments;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                opts = _arguments.length > 0 && _arguments[0] !== void 0 ? _arguments[0] : {};
                                return [
                                    4,
                                    this.send({
                                        type: 'presence',
                                        event: 'untrack'
                                    }, opts)
                                ];
                            case 1:
                                return [
                                    2,
                                    _state.sent()
                                ];
                        }
                    });
                }).apply(this, arguments);
            }
        },
        {
            key: "on",
            value: function on(type, filter, callback) {
                var _this = this;
                if (this.state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_STATES"].joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {
                    this.socket.log('channel', "resubscribe to ".concat(this.topic, " due to change in presence callbacks on joined channel"));
                    this.unsubscribe().then(function() {
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function() {
                            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                                switch(_state.label){
                                    case 0:
                                        return [
                                            4,
                                            this.subscribe()
                                        ];
                                    case 1:
                                        return [
                                            2,
                                            _state.sent()
                                        ];
                                }
                            });
                        }).call(_this);
                    });
                }
                return this._on(type, filter, callback);
            }
        },
        {
            key: "httpSend",
            value: /**
     * Sends a broadcast message explicitly via REST API.
     *
     * This method always uses the REST API endpoint regardless of WebSocket connection state.
     * Useful when you want to guarantee REST delivery or when gradually migrating from implicit REST fallback.
     *
     * @param event The name of the broadcast event
     * @param payload Payload to be sent (required)
     * @param opts Options including timeout
     * @returns Promise resolving to object with success status, and error details if failed
     */ function httpSend(_0, _1) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function(event, payload) {
                    var opts, _a, authorization, options, response, errorMessage, errorBody, _b;
                    var _arguments = arguments;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                opts = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : {};
                                authorization = this.socket.accessTokenValue ? "Bearer ".concat(this.socket.accessTokenValue) : '';
                                if (payload === undefined || payload === null) {
                                    return [
                                        2,
                                        Promise.reject('Payload is required for httpSend()')
                                    ];
                                }
                                options = {
                                    method: 'POST',
                                    headers: {
                                        Authorization: authorization,
                                        apikey: this.socket.apiKey ? this.socket.apiKey : '',
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({
                                        messages: [
                                            {
                                                topic: this.subTopic,
                                                event: event,
                                                payload: payload,
                                                private: this["private"]
                                            }
                                        ]
                                    })
                                };
                                return [
                                    4,
                                    this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout)
                                ];
                            case 1:
                                response = _state.sent();
                                if (response.status === 202) {
                                    return [
                                        2,
                                        {
                                            success: true
                                        }
                                    ];
                                }
                                errorMessage = response.statusText;
                                _state.label = 2;
                            case 2:
                                _state.trys.push([
                                    2,
                                    4,
                                    ,
                                    5
                                ]);
                                return [
                                    4,
                                    response.json()
                                ];
                            case 3:
                                errorBody = _state.sent();
                                errorMessage = errorBody.error || errorBody.message || errorMessage;
                                return [
                                    3,
                                    5
                                ];
                            case 4:
                                _b = _state.sent();
                                return [
                                    3,
                                    5
                                ];
                            case 5:
                                return [
                                    2,
                                    Promise.reject(new Error(errorMessage))
                                ];
                        }
                    });
                }).apply(this, arguments);
            }
        },
        {
            key: "send",
            value: /**
     * Sends a message into the channel.
     *
     * @param args Arguments to send to channel
     * @param args.type The type of event to send
     * @param args.event The name of the event being sent
     * @param args.payload Payload to be sent
     * @param opts Options to be used during the send process
     */ function send(_0) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function(args) {
                    var _this, opts, _a, _b, event, endpoint_payload, authorization, options, response, error;
                    var _arguments = arguments;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _this = this;
                                opts = _arguments.length > 1 && _arguments[1] !== void 0 ? _arguments[1] : {};
                                if (!(!this._canPush() && args.type === 'broadcast')) return [
                                    3,
                                    6
                                ];
                                console.warn('Realtime send() is automatically falling back to REST API. ' + 'This behavior will be deprecated in the future. ' + 'Please use httpSend() explicitly for REST delivery.');
                                event = args.event, endpoint_payload = args.payload;
                                authorization = this.socket.accessTokenValue ? "Bearer ".concat(this.socket.accessTokenValue) : '';
                                options = {
                                    method: 'POST',
                                    headers: {
                                        Authorization: authorization,
                                        apikey: this.socket.apiKey ? this.socket.apiKey : '',
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({
                                        messages: [
                                            {
                                                topic: this.subTopic,
                                                event: event,
                                                payload: endpoint_payload,
                                                private: this["private"]
                                            }
                                        ]
                                    })
                                };
                                _state.label = 1;
                            case 1:
                                _state.trys.push([
                                    1,
                                    4,
                                    ,
                                    5
                                ]);
                                return [
                                    4,
                                    this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout)
                                ];
                            case 2:
                                response = _state.sent();
                                return [
                                    4,
                                    (_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel()
                                ];
                            case 3:
                                _state.sent();
                                return [
                                    2,
                                    response.ok ? 'ok' : 'error'
                                ];
                            case 4:
                                error = _state.sent();
                                if (error.name === 'AbortError') {
                                    return [
                                        2,
                                        'timed out'
                                    ];
                                } else {
                                    return [
                                        2,
                                        'error'
                                    ];
                                }
                                //TURBOPACK unreachable
                                ;
                            case 5:
                                return [
                                    3,
                                    7
                                ];
                            case 6:
                                return [
                                    2,
                                    new Promise(function(resolve) {
                                        var _a, _b, _c;
                                        var push = _this._push(args.type, args, opts.timeout || _this.timeout);
                                        if (args.type === 'broadcast' && !((_c = (_b = (_a = _this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {
                                            resolve('ok');
                                        }
                                        push.receive('ok', function() {
                                            return resolve('ok');
                                        });
                                        push.receive('error', function() {
                                            return resolve('error');
                                        });
                                        push.receive('timeout', function() {
                                            return resolve('timed out');
                                        });
                                    })
                                ];
                            case 7:
                                return [
                                    2
                                ];
                        }
                    });
                }).apply(this, arguments);
            }
        },
        {
            /**
     * Updates the payload that will be sent the next time the channel joins (reconnects).
     * Useful for rotating access tokens or updating config without re-creating the channel.
     */ key: "updateJoinPayload",
            value: function updateJoinPayload(payload) {
                this.joinPush.updatePayload(payload);
            }
        },
        {
            /**
     * Leaves the channel.
     *
     * Unsubscribes from server events, and instructs channel to terminate on server.
     * Triggers onClose() hooks.
     *
     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
     * channel.unsubscribe().receive("ok", () => alert("left!") )
     */ key: "unsubscribe",
            value: function unsubscribe() {
                var _this = this;
                var timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.timeout;
                this.state = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_STATES"].leaving;
                var onClose = function() {
                    _this.socket.log('channel', "leave ".concat(_this.topic));
                    _this._trigger(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_EVENTS"].close, 'leave', _this._joinRef());
                };
                this.joinPush.destroy();
                var leavePush = null;
                return new Promise(function(resolve) {
                    leavePush = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$push$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](_this, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_EVENTS"].leave, {}, timeout);
                    leavePush.receive('ok', function() {
                        onClose();
                        resolve('ok');
                    }).receive('timeout', function() {
                        onClose();
                        resolve('timed out');
                    }).receive('error', function() {
                        resolve('error');
                    });
                    leavePush.send();
                    if (!_this._canPush()) {
                        leavePush.trigger('ok', {});
                    }
                })["finally"](function() {
                    leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();
                });
            }
        },
        {
            /**
     * Teardown the channel.
     *
     * Destroys and stops related timers.
     */ key: "teardown",
            value: function teardown() {
                this.pushBuffer.forEach(function(push) {
                    return push.destroy();
                });
                this.pushBuffer = [];
                this.rejoinTimer.reset();
                this.joinPush.destroy();
                this.state = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_STATES"].closed;
                this.bindings = {};
            }
        },
        {
            key: "_fetchWithTimeout",
            value: /** @internal */ function _fetchWithTimeout(url, options, timeout) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function() {
                    var controller, id, response;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                controller = new AbortController();
                                id = setTimeout(function() {
                                    return controller.abort();
                                }, timeout);
                                return [
                                    4,
                                    this.socket.fetch(url, Object.assign(Object.assign({}, options), {
                                        signal: controller.signal
                                    }))
                                ];
                            case 1:
                                response = _state.sent();
                                clearTimeout(id);
                                return [
                                    2,
                                    response
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            /** @internal */ key: "_push",
            value: function _push(event, payload) {
                var timeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.timeout;
                if (!this.joinedOnce) {
                    throw "tried to push '".concat(event, "' to '").concat(this.topic, "' before joining. Use channel.subscribe() before pushing events");
                }
                var pushEvent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$push$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this, event, payload, timeout);
                if (this._canPush()) {
                    pushEvent.send();
                } else {
                    this._addToPushBuffer(pushEvent);
                }
                return pushEvent;
            }
        },
        {
            /** @internal */ key: "_addToPushBuffer",
            value: function _addToPushBuffer(pushEvent) {
                pushEvent.startTimeout();
                this.pushBuffer.push(pushEvent);
                // Enforce buffer size limit
                if (this.pushBuffer.length > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_PUSH_BUFFER_SIZE"]) {
                    var removedPush = this.pushBuffer.shift();
                    if (removedPush) {
                        removedPush.destroy();
                        this.socket.log('channel', "discarded push due to buffer overflow: ".concat(removedPush.event), removedPush.payload);
                    }
                }
            }
        },
        {
            /**
     * Overridable message hook
     *
     * Receives all events for specialized message handling before dispatching to the channel callbacks.
     * Must return the payload, modified or unmodified.
     *
     * @internal
     */ key: "_onMessage",
            value: function _onMessage(_event, payload, _ref) {
                return payload;
            }
        },
        {
            /** @internal */ key: "_isMember",
            value: function _isMember(topic) {
                return this.topic === topic;
            }
        },
        {
            /** @internal */ key: "_joinRef",
            value: function _joinRef() {
                return this.joinPush.ref;
            }
        },
        {
            /** @internal */ key: "_trigger",
            value: function _trigger(type, payload, ref) {
                var _this = this;
                var _a, _b;
                var typeLower = type.toLocaleLowerCase();
                var close = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_EVENTS"].close, error = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_EVENTS"].error, leave = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_EVENTS"].leave, join = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_EVENTS"].join;
                var events = [
                    close,
                    error,
                    leave,
                    join
                ];
                if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {
                    return;
                }
                var handledPayload = this._onMessage(typeLower, payload, ref);
                if (payload && !handledPayload) {
                    throw 'channel onMessage callbacks must return the payload, modified or unmodified';
                }
                if ([
                    'insert',
                    'update',
                    'delete'
                ].includes(typeLower)) {
                    (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter(function(bind) {
                        var _a, _b, _c;
                        return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;
                    }).map(function(bind) {
                        return bind.callback(handledPayload, ref);
                    });
                } else {
                    (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter(function(bind) {
                        var _a, _b, _c, _d, _e, _f;
                        if ([
                            'broadcast',
                            'presence',
                            'postgres_changes'
                        ].includes(typeLower)) {
                            if ('id' in bind) {
                                var bindId = bind.id;
                                var bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;
                                return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === '*' || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));
                            } else {
                                var bindEvent1 = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();
                                return bindEvent1 === '*' || bindEvent1 === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());
                            }
                        } else {
                            return bind.type.toLocaleLowerCase() === typeLower;
                        }
                    }).map(function(bind) {
                        if ((typeof handledPayload === "undefined" ? "undefined" : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(handledPayload)) === 'object' && 'ids' in handledPayload) {
                            var postgresChanges = handledPayload.data;
                            var schema = postgresChanges.schema, table = postgresChanges.table, commit_timestamp = postgresChanges.commit_timestamp, _$type = postgresChanges.type, errors = postgresChanges.errors;
                            var enrichedPayload = {
                                schema: schema,
                                table: table,
                                commit_timestamp: commit_timestamp,
                                eventType: _$type,
                                "new": {},
                                old: {},
                                errors: errors
                            };
                            handledPayload = Object.assign(Object.assign({}, enrichedPayload), _this._getPayloadRecords(postgresChanges));
                        }
                        bind.callback(handledPayload, ref);
                    });
                }
            }
        },
        {
            /** @internal */ key: "_isClosed",
            value: function _isClosed() {
                return this.state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_STATES"].closed;
            }
        },
        {
            /** @internal */ key: "_isJoined",
            value: function _isJoined() {
                return this.state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_STATES"].joined;
            }
        },
        {
            /** @internal */ key: "_isJoining",
            value: function _isJoining() {
                return this.state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_STATES"].joining;
            }
        },
        {
            /** @internal */ key: "_isLeaving",
            value: function _isLeaving() {
                return this.state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_STATES"].leaving;
            }
        },
        {
            /** @internal */ key: "_replyEventName",
            value: function _replyEventName(ref) {
                return "chan_reply_".concat(ref);
            }
        },
        {
            /** @internal */ key: "_on",
            value: function _on(type, filter, callback) {
                var typeLower = type.toLocaleLowerCase();
                var binding = {
                    type: typeLower,
                    filter: filter,
                    callback: callback
                };
                if (this.bindings[typeLower]) {
                    this.bindings[typeLower].push(binding);
                } else {
                    this.bindings[typeLower] = [
                        binding
                    ];
                }
                return this;
            }
        },
        {
            /** @internal */ key: "_off",
            value: function _off(type, filter) {
                var typeLower = type.toLocaleLowerCase();
                if (this.bindings[typeLower]) {
                    this.bindings[typeLower] = this.bindings[typeLower].filter(function(bind) {
                        var _a;
                        return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));
                    });
                }
                return this;
            }
        },
        {
            /** @internal */ key: "_rejoinUntilConnected",
            value: function _rejoinUntilConnected() {
                this.rejoinTimer.scheduleTimeout();
                if (this.socket.isConnected()) {
                    this._rejoin();
                }
            }
        },
        {
            /**
     * Registers a callback that will be executed when the channel closes.
     *
     * @internal
     */ key: "_onClose",
            value: function _onClose(callback) {
                this._on(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_EVENTS"].close, {}, callback);
            }
        },
        {
            /**
     * Registers a callback that will be executed when the channel encounteres an error.
     *
     * @internal
     */ key: "_onError",
            value: function _onError(callback) {
                this._on(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_EVENTS"].error, {}, function(reason) {
                    return callback(reason);
                });
            }
        },
        {
            /**
     * Returns `true` if the socket is connected and the channel has been joined.
     *
     * @internal
     */ key: "_canPush",
            value: function _canPush() {
                return this.socket.isConnected() && this._isJoined();
            }
        },
        {
            /** @internal */ key: "_rejoin",
            value: function _rejoin() {
                var timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.timeout;
                if (this._isLeaving()) {
                    return;
                }
                this.socket._leaveOpenTopic(this.topic);
                this.state = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_STATES"].joining;
                this.joinPush.resend(timeout);
            }
        },
        {
            /** @internal */ key: "_getPayloadRecords",
            value: function _getPayloadRecords(payload) {
                var records = {
                    "new": {},
                    old: {}
                };
                if (payload.type === 'INSERT' || payload.type === 'UPDATE') {
                    records["new"] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$transformers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertChangeData"](payload.columns, payload.record);
                }
                if (payload.type === 'UPDATE' || payload.type === 'DELETE') {
                    records.old = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$transformers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertChangeData"](payload.columns, payload.old_record);
                }
                return records;
            }
        }
    ], [
        {
            key: "isEqual",
            value: /** @internal */ function isEqual(obj1, obj2) {
                if (Object.keys(obj1).length !== Object.keys(obj2).length) {
                    return false;
                }
                for(var k in obj1){
                    if (obj1[k] !== obj2[k]) {
                        return false;
                    }
                }
                return true;
            }
        },
        {
            key: "isFilterValueEqual",
            value: /**
     * Compares two optional filter values for equality.
     * Treats undefined, null, and empty string as equivalent empty values.
     * @internal
     */ function isFilterValueEqual(serverValue, clientValue) {
                var normalizedServer = serverValue !== null && serverValue !== void 0 ? serverValue : undefined;
                var normalizedClient = clientValue !== null && clientValue !== void 0 ? clientValue : undefined;
                return normalizedServer === normalizedClient;
            }
        }
    ]);
    return RealtimeChannel;
} //# sourceMappingURL=RealtimeChannel.js.map
();
;
}),
"[project]/node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>RealtimeClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_async_to_generator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_class_call_check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_create_class.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_to_consumable_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_to_consumable_array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/node_modules/tslib/tslib.es6.mjs [app-client] (ecmascript) <export __generator as _>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$websocket$2d$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/lib/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$serializer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/lib/serializer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$timer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/lib/timer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$transformers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/lib/transformers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$RealtimeChannel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
var noop = function() {};
// Connection-related constants
var CONNECTION_TIMEOUTS = {
    HEARTBEAT_INTERVAL: 25000,
    RECONNECT_DELAY: 10,
    HEARTBEAT_TIMEOUT_FALLBACK: 100
};
var RECONNECT_INTERVALS = [
    1000,
    2000,
    5000,
    10000
];
var DEFAULT_RECONNECT_FALLBACK = 10000;
var WORKER_SCRIPT = '\n  addEventListener("message", (e) => {\n    if (e.data.event === "start") {\n      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);\n    }\n  });';
var RealtimeClient = /*#__PURE__*/ function() {
    "use strict";
    function RealtimeClient(endPoint, options) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, RealtimeClient);
        var _a;
        this.accessTokenValue = null;
        this.apiKey = null;
        this._manuallySetToken = false;
        this.channels = new Array();
        this.endPoint = '';
        this.httpEndpoint = '';
        /** @deprecated headers cannot be set on websocket connections */ this.headers = {};
        this.params = {};
        this.timeout = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_TIMEOUT"];
        this.transport = null;
        this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;
        this.heartbeatTimer = undefined;
        this.pendingHeartbeatRef = null;
        this.heartbeatCallback = noop;
        this.ref = 0;
        this.reconnectTimer = null;
        this.vsn = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_VSN"];
        this.logger = noop;
        this.conn = null;
        this.sendBuffer = [];
        this.serializer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$serializer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        this.stateChangeCallbacks = {
            open: [],
            close: [],
            error: [],
            message: []
        };
        this.accessToken = null;
        this._connectionState = 'disconnected';
        this._wasManualDisconnect = false;
        this._authPromise = null;
        /**
         * Use either custom fetch, if provided, or default fetch to make HTTP requests
         *
         * @internal
         */ this._resolveFetch = function(customFetch) {
            if (customFetch) {
                return function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    return customFetch.apply(void 0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_to_consumable_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(args));
                };
            }
            return function() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                return fetch.apply(void 0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_to_consumable_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(args));
            };
        };
        // Validate required parameters
        if (!((_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey)) {
            throw new Error('API key is required to connect to Realtime');
        }
        this.apiKey = options.params.apikey;
        // Initialize endpoint URLs
        this.endPoint = "".concat(endPoint, "/").concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TRANSPORTS"].websocket);
        this.httpEndpoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$transformers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["httpEndpointURL"])(endPoint);
        this._initializeOptions(options);
        this._setupReconnectionTimer();
        this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(RealtimeClient, [
        {
            /**
     * Connects the socket, unless already connected.
     */ key: "connect",
            value: function connect() {
                // Skip if already connecting, disconnecting, or connected
                if (this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected()) {
                    return;
                }
                this._setConnectionState('connecting');
                // Trigger auth if needed and not already in progress
                // This ensures auth is called for standalone RealtimeClient usage
                // while avoiding race conditions with SupabaseClient's immediate setAuth call
                if (this.accessToken && !this._authPromise) {
                    this._setAuthSafely('connect');
                }
                // Establish WebSocket connection
                if (this.transport) {
                    // Use custom transport if provided
                    this.conn = new this.transport(this.endpointURL());
                } else {
                    // Try to use native WebSocket
                    try {
                        this.conn = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$websocket$2d$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createWebSocket(this.endpointURL());
                    } catch (error) {
                        this._setConnectionState('disconnected');
                        var errorMessage = error.message;
                        // Provide helpful error message based on environment
                        if (errorMessage.includes('Node.js')) {
                            throw new Error("".concat(errorMessage, "\n\n") + 'To use Realtime in Node.js, you need to provide a WebSocket implementation:\n\n' + 'Option 1: Use Node.js 22+ which has native WebSocket support\n' + 'Option 2: Install and provide the "ws" package:\n\n' + '  npm install ws\n\n' + '  import ws from "ws"\n' + '  const client = new RealtimeClient(url, {\n' + '    ...options,\n' + '    transport: ws\n' + '  })');
                        }
                        throw new Error("WebSocket not available: ".concat(errorMessage));
                    }
                }
                this._setupConnectionHandlers();
            }
        },
        {
            /**
     * Returns the URL of the websocket.
     * @returns string The URL of the websocket.
     */ key: "endpointURL",
            value: function endpointURL() {
                return this._appendParams(this.endPoint, Object.assign({}, this.params, {
                    vsn: this.vsn
                }));
            }
        },
        {
            /**
     * Disconnects the socket.
     *
     * @param code A numeric status code to send on disconnect.
     * @param reason A custom reason for the disconnect.
     */ key: "disconnect",
            value: function disconnect(code, reason) {
                var _this = this;
                if (this.isDisconnecting()) {
                    return;
                }
                this._setConnectionState('disconnecting', true);
                if (this.conn) {
                    // Setup fallback timer to prevent hanging in disconnecting state
                    var fallbackTimer = setTimeout(function() {
                        _this._setConnectionState('disconnected');
                    }, 100);
                    this.conn.onclose = function() {
                        clearTimeout(fallbackTimer);
                        _this._setConnectionState('disconnected');
                    };
                    // Close the WebSocket connection if close method exists
                    if (typeof this.conn.close === 'function') {
                        if (code) {
                            this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');
                        } else {
                            this.conn.close();
                        }
                    }
                    this._teardownConnection();
                } else {
                    this._setConnectionState('disconnected');
                }
            }
        },
        {
            /**
     * Returns all created channels
     */ key: "getChannels",
            value: function getChannels() {
                return this.channels;
            }
        },
        {
            key: "removeChannel",
            value: /**
     * Unsubscribes and removes a single channel
     * @param channel A RealtimeChannel instance
     */ function removeChannel(channel) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function() {
                    var status;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                return [
                                    4,
                                    channel.unsubscribe()
                                ];
                            case 1:
                                status = _state.sent();
                                if (this.channels.length === 0) {
                                    this.disconnect();
                                }
                                return [
                                    2,
                                    status
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "removeAllChannels",
            value: /**
     * Unsubscribes and removes all channels
     */ function removeAllChannels() {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function() {
                    var values_1;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                return [
                                    4,
                                    Promise.all(this.channels.map(function(channel) {
                                        return channel.unsubscribe();
                                    }))
                                ];
                            case 1:
                                values_1 = _state.sent();
                                this.channels = [];
                                this.disconnect();
                                return [
                                    2,
                                    values_1
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            /**
     * Logs the message.
     *
     * For customized logging, `this.logger` can be overridden.
     */ key: "log",
            value: function log(kind, msg, data) {
                this.logger(kind, msg, data);
            }
        },
        {
            /**
     * Returns the current state of the socket.
     */ key: "connectionState",
            value: function connectionState() {
                switch(this.conn && this.conn.readyState){
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SOCKET_STATES"].connecting:
                        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CONNECTION_STATE"].Connecting;
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SOCKET_STATES"].open:
                        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CONNECTION_STATE"].Open;
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SOCKET_STATES"].closing:
                        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CONNECTION_STATE"].Closing;
                    default:
                        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CONNECTION_STATE"].Closed;
                }
            }
        },
        {
            /**
     * Returns `true` is the connection is open.
     */ key: "isConnected",
            value: function isConnected() {
                return this.connectionState() === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CONNECTION_STATE"].Open;
            }
        },
        {
            /**
     * Returns `true` if the connection is currently connecting.
     */ key: "isConnecting",
            value: function isConnecting() {
                return this._connectionState === 'connecting';
            }
        },
        {
            /**
     * Returns `true` if the connection is currently disconnecting.
     */ key: "isDisconnecting",
            value: function isDisconnecting() {
                return this._connectionState === 'disconnecting';
            }
        },
        {
            /**
     * Creates (or reuses) a {@link RealtimeChannel} for the provided topic.
     *
     * Topics are automatically prefixed with `realtime:` to match the Realtime service.
     * If a channel with the same topic already exists it will be returned instead of creating
     * a duplicate connection.
     */ key: "channel",
            value: function channel(topic) {
                var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                    config: {}
                };
                var realtimeTopic = "realtime:".concat(topic);
                var exists = this.getChannels().find(function(c) {
                    return c.topic === realtimeTopic;
                });
                if (!exists) {
                    var chan = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$RealtimeChannel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]("realtime:".concat(topic), params, this);
                    this.channels.push(chan);
                    return chan;
                } else {
                    return exists;
                }
            }
        },
        {
            /**
     * Push out a message if the socket is connected.
     *
     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.
     */ key: "push",
            value: function push(data) {
                var _this = this;
                var topic = data.topic, event = data.event, payload = data.payload, ref = data.ref;
                var callback = function() {
                    _this.encode(data, function(result) {
                        var _a;
                        (_a = _this.conn) === null || _a === void 0 ? void 0 : _a.send(result);
                    });
                };
                this.log('push', "".concat(topic, " ").concat(event, " (").concat(ref, ")"), payload);
                if (this.isConnected()) {
                    callback();
                } else {
                    this.sendBuffer.push(callback);
                }
            }
        },
        {
            key: "setAuth",
            value: /**
     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.
     *
     * If param is null it will use the `accessToken` callback function or the token set on the client.
     *
     * On callback used, it will set the value of the token internal to the client.
     *
     * When a token is explicitly provided, it will be preserved across channel operations
     * (including removeChannel and resubscribe). The `accessToken` callback will not be
     * invoked until `setAuth()` is called without arguments.
     *
     * @param token A JWT string to override the token set on the client.
     *
     * @example
     * // Use a manual token (preserved across resubscribes, ignores accessToken callback)
     * client.realtime.setAuth('my-custom-jwt')
     *
     * // Switch back to using the accessToken callback
     * client.realtime.setAuth()
     */ function setAuth() {
                var token = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function() {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                this._authPromise = this._performAuth(token);
                                _state.label = 1;
                            case 1:
                                _state.trys.push([
                                    1,
                                    ,
                                    3,
                                    4
                                ]);
                                return [
                                    4,
                                    this._authPromise
                                ];
                            case 2:
                                _state.sent();
                                return [
                                    3,
                                    4
                                ];
                            case 3:
                                this._authPromise = null;
                                return [
                                    7
                                ];
                            case 4:
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            /**
     * Returns true if the current access token was explicitly set via setAuth(token),
     * false if it was obtained via the accessToken callback.
     * @internal
     */ key: "_isManualToken",
            value: function _isManualToken() {
                return this._manuallySetToken;
            }
        },
        {
            key: "sendHeartbeat",
            value: /**
     * Sends a heartbeat message if the socket is connected.
     */ function sendHeartbeat() {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function() {
                    var _this, _a;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                        _this = this;
                        if (!this.isConnected()) {
                            try {
                                this.heartbeatCallback('disconnected');
                            } catch (e) {
                                this.log('error', 'error in heartbeat callback', e);
                            }
                            return [
                                2
                            ];
                        }
                        // Handle heartbeat timeout and force reconnection if needed
                        if (this.pendingHeartbeatRef) {
                            this.pendingHeartbeatRef = null;
                            this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');
                            try {
                                this.heartbeatCallback('timeout');
                            } catch (e) {
                                this.log('error', 'error in heartbeat callback', e);
                            }
                            // Force reconnection after heartbeat timeout
                            this._wasManualDisconnect = false;
                            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WS_CLOSE_NORMAL"], 'heartbeat timeout');
                            setTimeout(function() {
                                var _a;
                                if (!_this.isConnected()) {
                                    (_a = _this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();
                                }
                            }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);
                            return [
                                2
                            ];
                        }
                        // Send heartbeat message to server
                        this.pendingHeartbeatRef = this._makeRef();
                        this.push({
                            topic: 'phoenix',
                            event: 'heartbeat',
                            payload: {},
                            ref: this.pendingHeartbeatRef
                        });
                        try {
                            this.heartbeatCallback('sent');
                        } catch (e) {
                            this.log('error', 'error in heartbeat callback', e);
                        }
                        this._setAuthSafely('heartbeat');
                        return [
                            2
                        ];
                    });
                }).call(this);
            }
        },
        {
            /**
     * Sets a callback that receives lifecycle events for internal heartbeat messages.
     * Useful for instrumenting connection health (e.g. sent/ok/timeout/disconnected).
     */ key: "onHeartbeat",
            value: function onHeartbeat(callback) {
                this.heartbeatCallback = callback;
            }
        },
        {
            /**
     * Flushes send buffer
     */ key: "flushSendBuffer",
            value: function flushSendBuffer() {
                if (this.isConnected() && this.sendBuffer.length > 0) {
                    this.sendBuffer.forEach(function(callback) {
                        return callback();
                    });
                    this.sendBuffer = [];
                }
            }
        },
        {
            /**
     * Return the next message ref, accounting for overflows
     *
     * @internal
     */ key: "_makeRef",
            value: function _makeRef() {
                var newRef = this.ref + 1;
                if (newRef === this.ref) {
                    this.ref = 0;
                } else {
                    this.ref = newRef;
                }
                return this.ref.toString();
            }
        },
        {
            /**
     * Unsubscribe from channels with the specified topic.
     *
     * @internal
     */ key: "_leaveOpenTopic",
            value: function _leaveOpenTopic(topic) {
                var dupChannel = this.channels.find(function(c) {
                    return c.topic === topic && (c._isJoined() || c._isJoining());
                });
                if (dupChannel) {
                    this.log('transport', 'leaving duplicate topic "'.concat(topic, '"'));
                    dupChannel.unsubscribe();
                }
            }
        },
        {
            /**
     * Removes a subscription from the socket.
     *
     * @param channel An open subscription.
     *
     * @internal
     */ key: "_remove",
            value: function _remove(channel) {
                this.channels = this.channels.filter(function(c) {
                    return c.topic !== channel.topic;
                });
            }
        },
        {
            /** @internal */ key: "_onConnMessage",
            value: function _onConnMessage(rawMessage) {
                var _this = this;
                this.decode(rawMessage.data, function(msg) {
                    // Handle heartbeat responses
                    if (msg.topic === 'phoenix' && msg.event === 'phx_reply') {
                        try {
                            _this.heartbeatCallback(msg.payload.status === 'ok' ? 'ok' : 'error');
                        } catch (e) {
                            _this.log('error', 'error in heartbeat callback', e);
                        }
                    }
                    // Handle pending heartbeat reference cleanup
                    if (msg.ref && msg.ref === _this.pendingHeartbeatRef) {
                        _this.pendingHeartbeatRef = null;
                    }
                    // Log incoming message
                    var topic = msg.topic, event = msg.event, payload = msg.payload, ref = msg.ref;
                    var refString = ref ? "(".concat(ref, ")") : '';
                    var status = payload.status || '';
                    _this.log('receive', "".concat(status, " ").concat(topic, " ").concat(event, " ").concat(refString).trim(), payload);
                    // Route message to appropriate channels
                    _this.channels.filter(function(channel) {
                        return channel._isMember(topic);
                    }).forEach(function(channel) {
                        return channel._trigger(event, payload, ref);
                    });
                    _this._triggerStateCallbacks('message', msg);
                });
            }
        },
        {
            /**
     * Clear specific timer
     * @internal
     */ key: "_clearTimer",
            value: function _clearTimer(timer) {
                var _a;
                if (timer === 'heartbeat' && this.heartbeatTimer) {
                    clearInterval(this.heartbeatTimer);
                    this.heartbeatTimer = undefined;
                } else if (timer === 'reconnect') {
                    (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.reset();
                }
            }
        },
        {
            /**
     * Clear all timers
     * @internal
     */ key: "_clearAllTimers",
            value: function _clearAllTimers() {
                this._clearTimer('heartbeat');
                this._clearTimer('reconnect');
            }
        },
        {
            /**
     * Setup connection handlers for WebSocket events
     * @internal
     */ key: "_setupConnectionHandlers",
            value: function _setupConnectionHandlers() {
                var _this = this;
                if (!this.conn) return;
                // Set binary type if supported (browsers and most WebSocket implementations)
                if ('binaryType' in this.conn) {
                    ;
                    this.conn.binaryType = 'arraybuffer';
                }
                this.conn.onopen = function() {
                    return _this._onConnOpen();
                };
                this.conn.onerror = function(error) {
                    return _this._onConnError(error);
                };
                this.conn.onmessage = function(event) {
                    return _this._onConnMessage(event);
                };
                this.conn.onclose = function(event) {
                    return _this._onConnClose(event);
                };
            }
        },
        {
            /**
     * Teardown connection and cleanup resources
     * @internal
     */ key: "_teardownConnection",
            value: function _teardownConnection() {
                if (this.conn) {
                    if (this.conn.readyState === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SOCKET_STATES"].open || this.conn.readyState === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SOCKET_STATES"].connecting) {
                        try {
                            this.conn.close();
                        } catch (e) {
                            this.log('error', 'Error closing connection', e);
                        }
                    }
                    this.conn.onopen = null;
                    this.conn.onerror = null;
                    this.conn.onmessage = null;
                    this.conn.onclose = null;
                    this.conn = null;
                }
                this._clearAllTimers();
                this.channels.forEach(function(channel) {
                    return channel.teardown();
                });
            }
        },
        {
            /** @internal */ key: "_onConnOpen",
            value: function _onConnOpen() {
                var _this = this;
                this._setConnectionState('connected');
                this.log('transport', "connected to ".concat(this.endpointURL()));
                // Wait for any pending auth operations before flushing send buffer
                // This ensures channel join messages include the correct access token
                var authPromise = this._authPromise || (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve());
                authPromise.then(function() {
                    _this.flushSendBuffer();
                })["catch"](function(e) {
                    _this.log('error', 'error waiting for auth on connect', e);
                    // Proceed anyway to avoid hanging connections
                    _this.flushSendBuffer();
                });
                this._clearTimer('reconnect');
                if (!this.worker) {
                    this._startHeartbeat();
                } else {
                    if (!this.workerRef) {
                        this._startWorkerHeartbeat();
                    }
                }
                this._triggerStateCallbacks('open');
            }
        },
        {
            /** @internal */ key: "_startHeartbeat",
            value: function _startHeartbeat() {
                var _this = this;
                this.heartbeatTimer && clearInterval(this.heartbeatTimer);
                this.heartbeatTimer = setInterval(function() {
                    return _this.sendHeartbeat();
                }, this.heartbeatIntervalMs);
            }
        },
        {
            /** @internal */ key: "_startWorkerHeartbeat",
            value: function _startWorkerHeartbeat() {
                var _this = this;
                if (this.workerUrl) {
                    this.log('worker', "starting worker for from ".concat(this.workerUrl));
                } else {
                    this.log('worker', "starting default worker");
                }
                var objectUrl = this._workerObjectUrl(this.workerUrl);
                this.workerRef = new Worker(objectUrl);
                this.workerRef.onerror = function(error) {
                    _this.log('worker', 'worker error', error.message);
                    _this.workerRef.terminate();
                };
                this.workerRef.onmessage = function(event) {
                    if (event.data.event === 'keepAlive') {
                        _this.sendHeartbeat();
                    }
                };
                this.workerRef.postMessage({
                    event: 'start',
                    interval: this.heartbeatIntervalMs
                });
            }
        },
        {
            /** @internal */ key: "_onConnClose",
            value: function _onConnClose(event) {
                var _a;
                this._setConnectionState('disconnected');
                this.log('transport', 'close', event);
                this._triggerChanError();
                this._clearTimer('heartbeat');
                // Only schedule reconnection if it wasn't a manual disconnect
                if (!this._wasManualDisconnect) {
                    (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();
                }
                this._triggerStateCallbacks('close', event);
            }
        },
        {
            /** @internal */ key: "_onConnError",
            value: function _onConnError(error) {
                this._setConnectionState('disconnected');
                this.log('transport', "".concat(error));
                this._triggerChanError();
                this._triggerStateCallbacks('error', error);
            }
        },
        {
            /** @internal */ key: "_triggerChanError",
            value: function _triggerChanError() {
                this.channels.forEach(function(channel) {
                    return channel._trigger(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_EVENTS"].error);
                });
            }
        },
        {
            /** @internal */ key: "_appendParams",
            value: function _appendParams(url, params) {
                if (Object.keys(params).length === 0) {
                    return url;
                }
                var prefix = url.match(/\?/) ? '&' : '?';
                var query = new URLSearchParams(params);
                return "".concat(url).concat(prefix).concat(query);
            }
        },
        {
            key: "_workerObjectUrl",
            value: function _workerObjectUrl(url) {
                var result_url;
                if (url) {
                    result_url = url;
                } else {
                    var blob = new Blob([
                        WORKER_SCRIPT
                    ], {
                        type: 'application/javascript'
                    });
                    result_url = URL.createObjectURL(blob);
                }
                return result_url;
            }
        },
        {
            /**
     * Set connection state with proper state management
     * @internal
     */ key: "_setConnectionState",
            value: function _setConnectionState(state) {
                var manual = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                this._connectionState = state;
                if (state === 'connecting') {
                    this._wasManualDisconnect = false;
                } else if (state === 'disconnecting') {
                    this._wasManualDisconnect = manual;
                }
            }
        },
        {
            key: "_performAuth",
            value: /**
     * Perform the actual auth operation
     * @internal
     */ function _performAuth() {
                var token = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function() {
                    var tokenToSend, isManualToken, e;
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                isManualToken = false;
                                if (!token) return [
                                    3,
                                    1
                                ];
                                tokenToSend = token;
                                // Track if this is a manually-provided token
                                isManualToken = true;
                                return [
                                    3,
                                    7
                                ];
                            case 1:
                                if (!this.accessToken) return [
                                    3,
                                    6
                                ];
                                _state.label = 2;
                            case 2:
                                _state.trys.push([
                                    2,
                                    4,
                                    ,
                                    5
                                ]);
                                return [
                                    4,
                                    this.accessToken()
                                ];
                            case 3:
                                tokenToSend = _state.sent();
                                return [
                                    3,
                                    5
                                ];
                            case 4:
                                e = _state.sent();
                                this.log('error', 'Error fetching access token from callback', e);
                                // Fall back to cached value if callback fails
                                tokenToSend = this.accessTokenValue;
                                return [
                                    3,
                                    5
                                ];
                            case 5:
                                return [
                                    3,
                                    7
                                ];
                            case 6:
                                tokenToSend = this.accessTokenValue;
                                _state.label = 7;
                            case 7:
                                // Track whether this token was manually set or fetched via callback
                                if (isManualToken) {
                                    this._manuallySetToken = true;
                                } else if (this.accessToken) {
                                    // If we used the callback, clear the manual flag
                                    this._manuallySetToken = false;
                                }
                                if (this.accessTokenValue != tokenToSend) {
                                    this.accessTokenValue = tokenToSend;
                                    this.channels.forEach(function(channel) {
                                        var payload = {
                                            access_token: tokenToSend,
                                            version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_VERSION"]
                                        };
                                        tokenToSend && channel.updateJoinPayload(payload);
                                        if (channel.joinedOnce && channel._isJoined()) {
                                            channel._push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CHANNEL_EVENTS"].access_token, {
                                                access_token: tokenToSend
                                            });
                                        }
                                    });
                                }
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "_waitForAuthIfNeeded",
            value: /**
     * Wait for any in-flight auth operations to complete
     * @internal
     */ function _waitForAuthIfNeeded() {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function() {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                if (!this._authPromise) return [
                                    3,
                                    2
                                ];
                                return [
                                    4,
                                    this._authPromise
                                ];
                            case 1:
                                _state.sent();
                                _state.label = 2;
                            case 2:
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            /**
     * Safely call setAuth with standardized error handling
     * @internal
     */ key: "_setAuthSafely",
            value: function _setAuthSafely() {
                var _this = this;
                var context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'general';
                // Only refresh auth if using callback-based tokens
                if (!this._isManualToken()) {
                    this.setAuth()["catch"](function(e) {
                        _this.log('error', "Error setting auth in ".concat(context), e);
                    });
                }
            }
        },
        {
            /**
     * Trigger state change callbacks with proper error handling
     * @internal
     */ key: "_triggerStateCallbacks",
            value: function _triggerStateCallbacks(event, data) {
                var _this = this;
                try {
                    this.stateChangeCallbacks[event].forEach(function(callback) {
                        try {
                            callback(data);
                        } catch (e) {
                            _this.log('error', "error in ".concat(event, " callback"), e);
                        }
                    });
                } catch (e) {
                    this.log('error', "error triggering ".concat(event, " callbacks"), e);
                }
            }
        },
        {
            /**
     * Setup reconnection timer with proper configuration
     * @internal
     */ key: "_setupReconnectionTimer",
            value: function _setupReconnectionTimer() {
                var _this = this;
                this.reconnectTimer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$timer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](function() {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function() {
                        var _this;
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                            _this = this;
                            setTimeout(function() {
                                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_async_to_generator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(function() {
                                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$node_modules$2f$tslib$2f$tslib$2e$es6$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$5f$_generator__as__$5f3e$__["_"])(this, function(_state) {
                                        switch(_state.label){
                                            case 0:
                                                return [
                                                    4,
                                                    this._waitForAuthIfNeeded()
                                                ];
                                            case 1:
                                                _state.sent();
                                                if (!this.isConnected()) {
                                                    this.connect();
                                                }
                                                return [
                                                    2
                                                ];
                                        }
                                    });
                                }).call(_this);
                            }, CONNECTION_TIMEOUTS.RECONNECT_DELAY);
                            return [
                                2
                            ];
                        });
                    }).call(_this);
                }, this.reconnectAfterMs);
            }
        },
        {
            /**
     * Initialize client options with defaults
     * @internal
     */ key: "_initializeOptions",
            value: function _initializeOptions(options) {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
                // Set defaults
                this.transport = (_a = options === null || options === void 0 ? void 0 : options.transport) !== null && _a !== void 0 ? _a : null;
                this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_TIMEOUT"];
                this.heartbeatIntervalMs = (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;
                this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;
                this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;
                this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop;
                this.vsn = (_g = options === null || options === void 0 ? void 0 : options.vsn) !== null && _g !== void 0 ? _g : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_VSN"];
                // Handle special cases
                if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;
                if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;
                if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {
                    this.logLevel = options.logLevel || options.log_level;
                    this.params = Object.assign(Object.assign({}, this.params), {
                        log_level: this.logLevel
                    });
                }
                // Set up functions with defaults
                this.reconnectAfterMs = (_h = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _h !== void 0 ? _h : function(tries) {
                    return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;
                };
                switch(this.vsn){
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VSN_1_0_0"]:
                        this.encode = (_j = options === null || options === void 0 ? void 0 : options.encode) !== null && _j !== void 0 ? _j : function(payload, callback) {
                            return callback(JSON.stringify(payload));
                        };
                        this.decode = (_k = options === null || options === void 0 ? void 0 : options.decode) !== null && _k !== void 0 ? _k : function(payload, callback) {
                            return callback(JSON.parse(payload));
                        };
                        break;
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VSN_2_0_0"]:
                        this.encode = (_l = options === null || options === void 0 ? void 0 : options.encode) !== null && _l !== void 0 ? _l : this.serializer.encode.bind(this.serializer);
                        this.decode = (_m = options === null || options === void 0 ? void 0 : options.decode) !== null && _m !== void 0 ? _m : this.serializer.decode.bind(this.serializer);
                        break;
                    default:
                        throw new Error("Unsupported serializer version: ".concat(this.vsn));
                }
                // Handle worker setup
                if (this.worker) {
                    if (typeof window !== 'undefined' && !window.Worker) {
                        throw new Error('Web Worker is not supported');
                    }
                    this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;
                }
            }
        }
    ]);
    return RealtimeClient;
} //# sourceMappingURL=RealtimeClient.js.map
();
;
}),
"[project]/node_modules/@supabase/realtime-js/dist/module/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$RealtimeClient$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$RealtimeChannel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$RealtimePresence$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$websocket$2d$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js [app-client] (ecmascript)");
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@supabase/realtime-js/dist/module/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "REALTIME_CHANNEL_STATES",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$RealtimeChannel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["REALTIME_CHANNEL_STATES"],
    "REALTIME_LISTEN_TYPES",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$RealtimeChannel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["REALTIME_LISTEN_TYPES"],
    "REALTIME_POSTGRES_CHANGES_LISTEN_EVENT",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$RealtimeChannel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["REALTIME_POSTGRES_CHANGES_LISTEN_EVENT"],
    "REALTIME_PRESENCE_LISTEN_EVENTS",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$RealtimePresence$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["REALTIME_PRESENCE_LISTEN_EVENTS"],
    "REALTIME_SUBSCRIBE_STATES",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$RealtimeChannel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["REALTIME_SUBSCRIBE_STATES"],
    "RealtimeChannel",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$RealtimeChannel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
    "RealtimeClient",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$RealtimeClient$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
    "RealtimePresence",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$RealtimePresence$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"],
    "WebSocketFactory",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$websocket$2d$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$RealtimeClient$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$RealtimeChannel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$RealtimePresence$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$realtime$2d$js$2f$dist$2f$module$2f$lib$2f$websocket$2d$factory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js [app-client] (ecmascript)");
}),
]);

//# sourceMappingURL=node_modules_%40supabase_realtime-js_dist_module_a6b8d2d8._.js.map