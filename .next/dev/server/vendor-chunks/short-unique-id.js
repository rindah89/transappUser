"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/short-unique-id";
exports.ids = ["vendor-chunks/short-unique-id"];
exports.modules = {

/***/ "(ssr)/./node_modules/short-unique-id/dist/short-unique-id.js":
/*!**************************************************************!*\
  !*** ./node_modules/short-unique-id/dist/short-unique-id.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\nvar ShortUniqueId = (() => {\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getOwnPropSymbols = Object.getOwnPropertySymbols;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __propIsEnum = Object.prototype.propertyIsEnumerable;\n  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\n  var __spreadValues = (a, b) => {\n    for (var prop in b || (b = {}))\n      if (__hasOwnProp.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols)\n      for (var prop of __getOwnPropSymbols(b)) {\n        if (__propIsEnum.call(b, prop))\n          __defNormalProp(a, prop, b[prop]);\n      }\n    return a;\n  };\n  var __export = (target, all) => {\n    for (var name in all)\n      __defProp(target, name, { get: all[name], enumerable: true });\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  // src/index.ts\n  var index_exports = {};\n  __export(index_exports, {\n    DEFAULT_OPTIONS: () => DEFAULT_OPTIONS,\n    DEFAULT_UUID_LENGTH: () => DEFAULT_UUID_LENGTH,\n    default: () => ShortUniqueId\n  });\n\n  // package.json\n  var version = \"5.3.2\";\n\n  // src/index.ts\n  var DEFAULT_UUID_LENGTH = 6;\n  var DEFAULT_OPTIONS = {\n    dictionary: \"alphanum\",\n    shuffle: true,\n    debug: false,\n    length: DEFAULT_UUID_LENGTH,\n    counter: 0\n  };\n  var _ShortUniqueId = class _ShortUniqueId {\n    constructor(argOptions = {}) {\n      __publicField(this, \"counter\");\n      __publicField(this, \"debug\");\n      __publicField(this, \"dict\");\n      __publicField(this, \"version\");\n      __publicField(this, \"dictIndex\", 0);\n      __publicField(this, \"dictRange\", []);\n      __publicField(this, \"lowerBound\", 0);\n      __publicField(this, \"upperBound\", 0);\n      __publicField(this, \"dictLength\", 0);\n      __publicField(this, \"uuidLength\");\n      __publicField(this, \"_digit_first_ascii\", 48);\n      __publicField(this, \"_digit_last_ascii\", 58);\n      __publicField(this, \"_alpha_lower_first_ascii\", 97);\n      __publicField(this, \"_alpha_lower_last_ascii\", 123);\n      __publicField(this, \"_hex_last_ascii\", 103);\n      __publicField(this, \"_alpha_upper_first_ascii\", 65);\n      __publicField(this, \"_alpha_upper_last_ascii\", 91);\n      __publicField(this, \"_number_dict_ranges\", {\n        digits: [this._digit_first_ascii, this._digit_last_ascii]\n      });\n      __publicField(this, \"_alpha_dict_ranges\", {\n        lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],\n        upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii]\n      });\n      __publicField(this, \"_alpha_lower_dict_ranges\", {\n        lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii]\n      });\n      __publicField(this, \"_alpha_upper_dict_ranges\", {\n        upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii]\n      });\n      __publicField(this, \"_alphanum_dict_ranges\", {\n        digits: [this._digit_first_ascii, this._digit_last_ascii],\n        lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],\n        upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii]\n      });\n      __publicField(this, \"_alphanum_lower_dict_ranges\", {\n        digits: [this._digit_first_ascii, this._digit_last_ascii],\n        lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii]\n      });\n      __publicField(this, \"_alphanum_upper_dict_ranges\", {\n        digits: [this._digit_first_ascii, this._digit_last_ascii],\n        upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii]\n      });\n      __publicField(this, \"_hex_dict_ranges\", {\n        decDigits: [this._digit_first_ascii, this._digit_last_ascii],\n        alphaDigits: [this._alpha_lower_first_ascii, this._hex_last_ascii]\n      });\n      __publicField(this, \"_dict_ranges\", {\n        _number_dict_ranges: this._number_dict_ranges,\n        _alpha_dict_ranges: this._alpha_dict_ranges,\n        _alpha_lower_dict_ranges: this._alpha_lower_dict_ranges,\n        _alpha_upper_dict_ranges: this._alpha_upper_dict_ranges,\n        _alphanum_dict_ranges: this._alphanum_dict_ranges,\n        _alphanum_lower_dict_ranges: this._alphanum_lower_dict_ranges,\n        _alphanum_upper_dict_ranges: this._alphanum_upper_dict_ranges,\n        _hex_dict_ranges: this._hex_dict_ranges\n      });\n      /* tslint:disable consistent-return */\n      __publicField(this, \"log\", (...args) => {\n        const finalArgs = [...args];\n        finalArgs[0] = \"[short-unique-id] \".concat(args[0]);\n        if (this.debug === true) {\n          if (typeof console !== \"undefined\" && console !== null) {\n            console.log(...finalArgs);\n            return;\n          }\n        }\n      });\n      /* tslint:enable consistent-return */\n      __publicField(this, \"_normalizeDictionary\", (dictionary, shuffle) => {\n        let finalDict;\n        if (dictionary && Array.isArray(dictionary) && dictionary.length > 1) {\n          finalDict = dictionary;\n        } else {\n          finalDict = [];\n          this.dictIndex = 0;\n          const rangesName = \"_\".concat(dictionary, \"_dict_ranges\");\n          const ranges = this._dict_ranges[rangesName];\n          let capacity = 0;\n          for (const [, rangeValue] of Object.entries(ranges)) {\n            const [lower, upper] = rangeValue;\n            capacity += Math.abs(upper - lower);\n          }\n          finalDict = new Array(capacity);\n          let dictIdx = 0;\n          for (const [, rangeTypeValue] of Object.entries(ranges)) {\n            this.dictRange = rangeTypeValue;\n            this.lowerBound = this.dictRange[0];\n            this.upperBound = this.dictRange[1];\n            const isAscending = this.lowerBound <= this.upperBound;\n            const start = this.lowerBound;\n            const end = this.upperBound;\n            if (isAscending) {\n              for (let i = start; i < end; i++) {\n                finalDict[dictIdx++] = String.fromCharCode(i);\n                this.dictIndex = i;\n              }\n            } else {\n              for (let i = start; i > end; i--) {\n                finalDict[dictIdx++] = String.fromCharCode(i);\n                this.dictIndex = i;\n              }\n            }\n          }\n          finalDict.length = dictIdx;\n        }\n        if (shuffle) {\n          const len = finalDict.length;\n          for (let i = len - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [finalDict[i], finalDict[j]] = [finalDict[j], finalDict[i]];\n          }\n        }\n        return finalDict;\n      });\n      /** Change the dictionary after initialization. */\n      __publicField(this, \"setDictionary\", (dictionary, shuffle) => {\n        this.dict = this._normalizeDictionary(dictionary, shuffle);\n        this.dictLength = this.dict.length;\n        this.setCounter(0);\n      });\n      __publicField(this, \"seq\", () => {\n        return this.sequentialUUID();\n      });\n      /**\n       * Generates UUID based on internal counter that's incremented after each ID generation.\n       * @alias `const uid = new ShortUniqueId(); uid.seq();`\n       */\n      __publicField(this, \"sequentialUUID\", () => {\n        const dictLen = this.dictLength;\n        const dict = this.dict;\n        let counterDiv = this.counter;\n        const idParts = [];\n        do {\n          const counterRem = counterDiv % dictLen;\n          counterDiv = Math.trunc(counterDiv / dictLen);\n          idParts.push(dict[counterRem]);\n        } while (counterDiv !== 0);\n        const id = idParts.join(\"\");\n        this.counter += 1;\n        return id;\n      });\n      __publicField(this, \"rnd\", (uuidLength = this.uuidLength || DEFAULT_UUID_LENGTH) => {\n        return this.randomUUID(uuidLength);\n      });\n      /**\n       * Generates UUID by creating each part randomly.\n       * @alias `const uid = new ShortUniqueId(); uid.rnd(uuidLength: number);`\n       */\n      __publicField(this, \"randomUUID\", (uuidLength = this.uuidLength || DEFAULT_UUID_LENGTH) => {\n        if (uuidLength === null || typeof uuidLength === \"undefined\" || uuidLength < 1) {\n          throw new Error(\"Invalid UUID Length Provided\");\n        }\n        const result = new Array(uuidLength);\n        const dictLen = this.dictLength;\n        const dict = this.dict;\n        for (let j = 0; j < uuidLength; j++) {\n          const randomPartIdx = Math.floor(Math.random() * dictLen);\n          result[j] = dict[randomPartIdx];\n        }\n        return result.join(\"\");\n      });\n      __publicField(this, \"fmt\", (format, date) => {\n        return this.formattedUUID(format, date);\n      });\n      /**\n       * Generates custom UUID with the provided format string.\n       * @alias `const uid = new ShortUniqueId(); uid.fmt(format: string);`\n       */\n      __publicField(this, \"formattedUUID\", (format, date) => {\n        const fnMap = {\n          $r: this.randomUUID,\n          $s: this.sequentialUUID,\n          $t: this.stamp\n        };\n        const result = format.replace(/\\$[rs]\\d{0,}|\\$t0|\\$t[1-9]\\d{1,}/g, (m) => {\n          const fn = m.slice(0, 2);\n          const len = Number.parseInt(m.slice(2), 10);\n          if (fn === \"$s\") {\n            return fnMap[fn]().padStart(len, \"0\");\n          }\n          if (fn === \"$t\" && date) {\n            return fnMap[fn](len, date);\n          }\n          return fnMap[fn](len);\n        });\n        return result;\n      });\n      /**\n       * Calculates total number of possible UUIDs.\n       *\n       * Given that:\n       *\n       * - `H` is the total number of possible UUIDs\n       * - `n` is the number of unique characters in the dictionary\n       * - `l` is the UUID length\n       *\n       * Then `H` is defined as `n` to the power of `l`:\n       *\n       * <div style=\"background: white; padding: 5px; border-radius: 5px; overflow: hidden;\">\n       *  <img src=\"data:image/png;base64,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\" />\n       * </div>\n       *\n       * This function returns `H`.\n       */\n      __publicField(this, \"availableUUIDs\", (uuidLength = this.uuidLength) => {\n        return Number.parseFloat(([...new Set(this.dict)].length ** uuidLength).toFixed(0));\n      });\n      /**\n       * Calculates approximate number of hashes before first collision.\n       *\n       * Given that:\n       *\n       * - `H` is the total number of possible UUIDs, or in terms of this library,\n       * the result of running `availableUUIDs()`\n       * - the expected number of values we have to choose before finding the\n       * first collision can be expressed as the quantity `Q(H)`\n       *\n       * Then `Q(H)` can be approximated as the square root of the product of half\n       * of pi times `H`:\n       *\n       * <div style=\"background: white; padding: 5px; border-radius: 5px; overflow: hidden;\">\n       *  <img src=\"data:image/png;base64,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\" />\n       * </div>\n       *\n       * This function returns `Q(H)`.\n       *\n       * (see [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution))\n       */\n      // Cache for memoization\n      __publicField(this, \"_collisionCache\", /* @__PURE__ */ new Map());\n      __publicField(this, \"approxMaxBeforeCollision\", (rounds = this.availableUUIDs(this.uuidLength)) => {\n        const cacheKey = rounds;\n        const cached = this._collisionCache.get(cacheKey);\n        if (cached !== void 0) {\n          return cached;\n        }\n        const result = Number.parseFloat(Math.sqrt(Math.PI / 2 * rounds).toFixed(20));\n        this._collisionCache.set(cacheKey, result);\n        return result;\n      });\n      /**\n       * Calculates probability of generating duplicate UUIDs (a collision) in a\n       * given number of UUID generation rounds.\n       *\n       * Given that:\n       *\n       * - `r` is the maximum number of times that `randomUUID()` will be called,\n       * or better said the number of _rounds_\n       * - `H` is the total number of possible UUIDs, or in terms of this library,\n       * the result of running `availableUUIDs()`\n       *\n       * Then the probability of collision `p(r; H)` can be approximated as the result\n       * of dividing the square root of the product of half of pi times `r` by `H`:\n       *\n       * <div style=\"background: white; padding: 5px; border-radius: 5px; overflow: hidden;\">\n       *  <img src=\"data:image/png;base64,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\" />\n       * </div>\n       *\n       * This function returns `p(r; H)`.\n       *\n       * (see [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution))\n       *\n       * (Useful if you are wondering _\"If I use this lib and expect to perform at most\n       * `r` rounds of UUID generations, what is the probability that I will hit a duplicate UUID?\"_.)\n       */\n      __publicField(this, \"collisionProbability\", (rounds = this.availableUUIDs(this.uuidLength), uuidLength = this.uuidLength) => {\n        return Number.parseFloat(\n          (this.approxMaxBeforeCollision(rounds) / this.availableUUIDs(uuidLength)).toFixed(20)\n        );\n      });\n      /**\n       * Calculate a \"uniqueness\" score (from 0 to 1) of UUIDs based on size of\n       * dictionary and chosen UUID length.\n       *\n       * Given that:\n       *\n       * - `H` is the total number of possible UUIDs, or in terms of this library,\n       * the result of running `availableUUIDs()`\n       * - `Q(H)` is the approximate number of hashes before first collision,\n       * or in terms of this library, the result of running `approxMaxBeforeCollision()`\n       *\n       * Then `uniqueness` can be expressed as the additive inverse of the probability of\n       * generating a \"word\" I had previously generated (a duplicate) at any given iteration\n       * up to the the total number of possible UUIDs expressed as the quotiend of `Q(H)` and `H`:\n       *\n       * <div style=\"background: white; padding: 5px; border-radius: 5px; overflow: hidden;\">\n       *  <img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIcAAABDCAYAAAC2nhaoAAAJK0lEQVR4Ae2dB+w9RRHHvyCgYgUVxViCBQIRFRQEFVEERVGKggYwJiAkxCgqECkRJQqiCQjSYsEYCyrFggRDSywUpSN/ihXQINUCCigK4vvEmWS5XJm99/+/37t3O8nl3tudLTc7tzM7M7snFZgVBVaSdLikrWfVYEM7x0vaqCGvJAco8BhJW0raV9IRkg6V9B5JawfKNqGcKOljTZkzTH+apEslvXKGbS5EU8+T9FlJv5Z0jKQ3S3qZpNdJ+rikuySdIekFmU/7YUnfC5Z5iqRf2XWFpPT6paTfS9oqqeuxkq6zPqe4/L7G8LdP8Pm5nqTfSHpWJb38raHAKpL2l3SPzRRPrcEh6en21v3FGKYB7VHJm0q6U9IzH5Xa/udxkp4vCRHwiF0flLSWpNVrisIgMPZnEvyDbPCfUINP0n6T2fHHkhB3BRoosOZED7hI0t8kvb4BJ01mkP8sCQZZJ82o+b2yMdMBNXmRpBNssP8YQZZ0pOHTN0RjG6xqs8pubUhjznuOpOsl3SeJNzwK6A680V2iYg8TRXVve6StZdbO1yLIki4x/O8H8feR9CdJTwzijwbtyZJuNGK+K/OpX2zl/ivphS1l0RGObslvy3rGRM+hfphwzzZEy2OA/234Hwrgg0KZv0uCSQoYBZCzvF0Q/ts9qEJ5xBDl399QHqWR/I0b8ruSd7by1BFRgLdN8FGio/AtSZdFkceAx5sC0XnTIoSvowkrGur4Yl3mRBn8wuSNvGMKhS9X33BlFH0DXScK77XneEm0wCLjPckGjYHF9tAXbjGiNukd5PeZlbw/LE/pY1Tf+EVHf7ze6p1VDu2w3B49YK+AGFzr96QGYuVfVsdpNXW4TsJysg/k6hswfK6+kfbrbkmnpwlj/M2g3myDirLYFzAeOYMx/VdhR8t/ezUj+H+XpP6I2Htrgp+jb3h3fjZReqPLZS+zcHdMxj6omMT7wnZJPXUK6cGW39eH4foGff1r4Lrf2sP+kqNv+POfMnERPCxpNU8Y4/0TyaC+cQoCYGJ3JqsTTT64fX0x2F6o/8vBPv7c8L8bxK+iHWXl25bl1TIL9x+5CtF5S/Bh9AV8H9SDnQRRVQWUSPKxpeQCJnK3b+Ds64LUvoGjsA8cZv19RZ/Ci1LmJ0aE26d4IEQFA8/1gYZ6cM6Rj88jFzDIef2sJLoA56Djv7QLuSH/QKsDB+NoAUcThLx2Cgp83eq4tcXs7DMUDrRcYHlNH/G+RuDThp9r30jrPsTq2DxNHNtvlp0QHhtCH3hRsmTctaUCFytrtOA0Zbm+8ZUmhEq6+1P66htU90mjy6gNYT59YvrOBXSLC4yI32nQNbzOzxkebvccSPUNLJddgEPvQWsLl35fONbqiIixvm3MfTneDFf2mAVSwP3O6gBfA6uNqqcS/YJZ5ypJTTESXh8DBe5rPCF4f7eVo2yEsd6U4G8YbKMODTH4z4Cbv67sQqWdZQRlKnV4tkV4uRhY14J+PH+nSYjfQ5Iut4AfT2+6v8XaaBM9dWVPsnIY6iJACCOM1Ne+4W0QNjiNUdDrGfydNxJicrkdAjHw3MqTYRgC9ra3CpkeXZoSQMRymeCbHPAlctSfcrExR5N/J9I2RjPiWaJtRuocNM6rzPl2tYXXsQKpAlPtDwyPoJ1c4E08t6MQAwNTYvJ2fYiZgLZfXeMxBh/xt9kkEg3R5SLybBNhGLHq7C5t3djAGKxEhCVUYtZAxyBo+HcWYU5MxPtscJDBvPl1UVwMXBfgQses3bacfblFb50/Gdy6i5UISqoD4o60OlzSyIvoKl4fd5gMkUl8bBbAqZicI5pzVsVzhIxyCVPsZUYtjFAMAnK4znGGIktkehdQB282+sc8wzmTgKQf5nSQ6OvdTQFjmkuVt5x6hoz7W5tN0mcgSv1HkjZJE1t+Y3Rj2TuvQAwts8Y2kQ5+1aKqb7LlnAeQjJE5UFj/kCiqyHpWOtAkCq81ZZbV0DwC1tUro3oKQSOp29Z9BGNkDhiDWZM3C18MvxETuf6Hb9r+k3ljDgKK7jXltlffxswc7kOBKfz6aA8qovjih0H5nCfg+dg01RvGzBwMKkvE2ybbD4mU2qE3FaUtbFtjl2V1iiayir7DnimVElkVgDxm5sgmVkcBFHwMaawAlxLYKnFhn6VrtdOFOaoUme4/sRfs3l9KQDQ27QXO6ldhjixyjQu5MMe4xjvraQtzZJFrXMiFOcY13llPu7yYAxc2fgo260x79dm0w7KU5Vu54jTo3AC+vJgDZxZb7iIbdLpwzsti7/8jsyPsH+XKogGBR62wvJijtZGSOUwKFOYY5rjNpNeFOWZC5mE2UphjmOM2k17jC8Aj+amZtFYaGQwFCFQlEATm+MZgel06usIowK5uIp8JVuUwD49j4H7DJCKaZSRbCt+wwnpQKp5bCnBcEedxshW/6SIsfl7D3uaRsNCUs8GIdOdwufT60uToqVMr9GSrArvuTq7gejlezshpP/NIi9KnCgXY2sCxk8zKHpNLuCG71d422X9LnCmByw5sZWBmJv7Dj4xg5uY8U6zMBA5NFaTjDZX7fFHgTBPVbHuIAPGnLtIj+AVnoBRAwceFwGAza0TAj7M8LoJccIZLARyGMAYXu+O7AL3C8d/ZhVzyh00BziNnsP8z0R/YAtIFbMsEH/0k3RLZVa7kD5ACftY6O+MjgG0J5pjmiKpIOwVniSlAxDk76BjsqL7hm6qKvrHEg7eim2dDE4zBFdE32Kzt+EXfWNGjs8T1c+g8gx3VNzgwBnz0jeyjEZb4WUvzmRRwfeOBlrM10jM3XKQUfSOT0ENDR9/gjFBmAs4YbXJLpOmOX/SNoY12Zn/TE48jDkuObnJ9g4DoAgtMgY/YYPN9lscHnjO1bxR9I0CwIaO4P+WnwYfwox/K0Y9Bgg0VDX2DrRaIiegBOK6Mfn6oD136HaMAG4Ncf4h83yX1pxR9I0bjwWLxSXCYg/PJ646srD4Y348Fv9g3qpRZwP8c4chgc1hKBPxrC0XfiFBrwDh8S94/THx48DlK/EaQUENGQxF1EzgzB19cIK0JCBNMv9DEBwRhrgILRAE+icFXqLmqG8I5fH5Z5Vn5ymQVz/+Dz0G5q1bKzOzv/wAvzKhnhyEMfQAAAABJRU5ErkJggg==\" />\n       * </div>\n       *\n       * (Useful if you need a value to rate the \"quality\" of the combination of given dictionary\n       * and UUID length. The closer to 1, higher the uniqueness and thus better the quality.)\n       */\n      __publicField(this, \"uniqueness\", (rounds = this.availableUUIDs(this.uuidLength)) => {\n        const score = Number.parseFloat(\n          (1 - this.approxMaxBeforeCollision(rounds) / rounds).toFixed(20)\n        );\n        return score > 1 ? 1 : score < 0 ? 0 : score;\n      });\n      /**\n       * Return the version of this module.\n       */\n      __publicField(this, \"getVersion\", () => {\n        return this.version;\n      });\n      /**\n       * Generates a UUID with a timestamp that can be extracted using `uid.parseStamp(stampString);`.\n       *\n       * ```js\n       *  const uidWithTimestamp = uid.stamp(32);\n       *  console.log(uidWithTimestamp);\n       *  // GDa608f973aRCHLXQYPTbKDbjDeVsSb3\n       *\n       *  console.log(uid.parseStamp(uidWithTimestamp));\n       *  // 2021-05-03T06:24:58.000Z\n       *  ```\n       */\n      __publicField(this, \"stamp\", (finalLength, date) => {\n        const hexStamp = Math.floor(+(date || /* @__PURE__ */ new Date()) / 1e3).toString(16);\n        if (typeof finalLength === \"number\" && finalLength === 0) {\n          return hexStamp;\n        }\n        if (typeof finalLength !== \"number\" || finalLength < 10) {\n          throw new Error(\n            [\n              \"Param finalLength must be a number greater than or equal to 10,\",\n              \"or 0 if you want the raw hexadecimal timestamp\"\n            ].join(\"\\n\")\n          );\n        }\n        const idLength = finalLength - 9;\n        const rndIdx = Math.round(Math.random() * (idLength > 15 ? 15 : idLength));\n        const id = this.randomUUID(idLength);\n        return \"\".concat(id.substring(0, rndIdx)).concat(hexStamp).concat(id.substring(rndIdx)).concat(rndIdx.toString(16));\n      });\n      /**\n       * Extracts the date embeded in a UUID generated using the `uid.stamp(finalLength);` method.\n       *\n       * ```js\n       *  const uidWithTimestamp = uid.stamp(32);\n       *  console.log(uidWithTimestamp);\n       *  // GDa608f973aRCHLXQYPTbKDbjDeVsSb3\n       *\n       *  console.log(uid.parseStamp(uidWithTimestamp));\n       *  // 2021-05-03T06:24:58.000Z\n       *  ```\n       */\n      __publicField(this, \"parseStamp\", (suid, format) => {\n        if (format && !/t0|t[1-9]\\d{1,}/.test(format)) {\n          throw new Error(\"Cannot extract date from a formated UUID with no timestamp in the format\");\n        }\n        const stamp = format ? format.replace(/\\$[rs]\\d{0,}|\\$t0|\\$t[1-9]\\d{1,}/g, (m) => {\n          const fnMap = {\n            $r: (len2) => [...Array(len2)].map(() => \"r\").join(\"\"),\n            $s: (len2) => [...Array(len2)].map(() => \"s\").join(\"\"),\n            $t: (len2) => [...Array(len2)].map(() => \"t\").join(\"\")\n          };\n          const fn = m.slice(0, 2);\n          const len = Number.parseInt(m.slice(2), 10);\n          return fnMap[fn](len);\n        }).replace(/^(.*?)(t{8,})(.*)$/g, (_m, p1, p2) => {\n          return suid.substring(p1.length, p1.length + p2.length);\n        }) : suid;\n        if (stamp.length === 8) {\n          return new Date(Number.parseInt(stamp, 16) * 1e3);\n        }\n        if (stamp.length < 10) {\n          throw new Error(\"Stamp length invalid\");\n        }\n        const rndIdx = Number.parseInt(stamp.substring(stamp.length - 1), 16);\n        return new Date(Number.parseInt(stamp.substring(rndIdx, rndIdx + 8), 16) * 1e3);\n      });\n      /**\n       * Set the counter to a specific value.\n       */\n      __publicField(this, \"setCounter\", (counter) => {\n        this.counter = counter;\n      });\n      /**\n       * Validate given UID contains only characters from the instanced dictionary or optionally provided dictionary.\n       */\n      __publicField(this, \"validate\", (uid, dictionary) => {\n        const finalDictionary = dictionary ? this._normalizeDictionary(dictionary) : this.dict;\n        return uid.split(\"\").every((c) => finalDictionary.includes(c));\n      });\n      const options = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS), argOptions);\n      this.counter = 0;\n      this.debug = false;\n      this.dict = [];\n      this.version = version;\n      const { dictionary, shuffle, length, counter } = options;\n      this.uuidLength = length;\n      this.setDictionary(dictionary, shuffle);\n      this.setCounter(counter);\n      this.debug = options.debug;\n      this.log(this.dict);\n      this.log(\n        \"Generator instantiated with Dictionary Size \".concat(this.dictLength, \" and counter set to \").concat(this.counter)\n      );\n      this.log = this.log.bind(this);\n      this.setDictionary = this.setDictionary.bind(this);\n      this.setCounter = this.setCounter.bind(this);\n      this.seq = this.seq.bind(this);\n      this.sequentialUUID = this.sequentialUUID.bind(this);\n      this.rnd = this.rnd.bind(this);\n      this.randomUUID = this.randomUUID.bind(this);\n      this.fmt = this.fmt.bind(this);\n      this.formattedUUID = this.formattedUUID.bind(this);\n      this.availableUUIDs = this.availableUUIDs.bind(this);\n      this.approxMaxBeforeCollision = this.approxMaxBeforeCollision.bind(this);\n      this.collisionProbability = this.collisionProbability.bind(this);\n      this.uniqueness = this.uniqueness.bind(this);\n      this.getVersion = this.getVersion.bind(this);\n      this.stamp = this.stamp.bind(this);\n      this.parseStamp = this.parseStamp.bind(this);\n    }\n  };\n  /** @hidden */\n  __publicField(_ShortUniqueId, \"default\", _ShortUniqueId);\n  var ShortUniqueId = _ShortUniqueId;\n  return __toCommonJS(index_exports);\n})();\n//# sourceMappingURL=short-unique-id.js.map\n true&&(module.exports=ShortUniqueId.default),'undefined'!=typeof window&&(ShortUniqueId=ShortUniqueId.default);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2hvcnQtdW5pcXVlLWlkL2Rpc3Qvc2hvcnQtdW5pcXVlLWlkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsNkRBQTZEO0FBQzdJO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNEZBQTRGO0FBQzNIO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrQkFBa0IsYUFBYTtBQUNyRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0JBQW9CLEdBQUc7QUFDaEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVDQUF1QztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxLQUEwQiIsInNvdXJjZXMiOlsiL1VzZXJzL3JlbXluZ3dhbnlhbS9EZXNrdG9wL3RyYW5zYXBwL3RyYW5zYXBwLXVzZXItbWFzdGVyL25vZGVfbW9kdWxlcy9zaG9ydC11bmlxdWUtaWQvZGlzdC9zaG9ydC11bmlxdWUtaWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgU2hvcnRVbmlxdWVJZCA9ICgoKSA9PiB7XG4gIHZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gIHZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgdmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG4gIHZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiAgdmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICB2YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG4gIHZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfTtcbiAgdmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICB9O1xuICB2YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICAgIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gICAgfVxuICAgIHJldHVybiB0bztcbiAgfTtcbiAgdmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG4gIHZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcblxuICAvLyBzcmMvaW5kZXgudHNcbiAgdmFyIGluZGV4X2V4cG9ydHMgPSB7fTtcbiAgX19leHBvcnQoaW5kZXhfZXhwb3J0cywge1xuICAgIERFRkFVTFRfT1BUSU9OUzogKCkgPT4gREVGQVVMVF9PUFRJT05TLFxuICAgIERFRkFVTFRfVVVJRF9MRU5HVEg6ICgpID0+IERFRkFVTFRfVVVJRF9MRU5HVEgsXG4gICAgZGVmYXVsdDogKCkgPT4gU2hvcnRVbmlxdWVJZFxuICB9KTtcblxuICAvLyBwYWNrYWdlLmpzb25cbiAgdmFyIHZlcnNpb24gPSBcIjUuMy4yXCI7XG5cbiAgLy8gc3JjL2luZGV4LnRzXG4gIHZhciBERUZBVUxUX1VVSURfTEVOR1RIID0gNjtcbiAgdmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBkaWN0aW9uYXJ5OiBcImFscGhhbnVtXCIsXG4gICAgc2h1ZmZsZTogdHJ1ZSxcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgbGVuZ3RoOiBERUZBVUxUX1VVSURfTEVOR1RILFxuICAgIGNvdW50ZXI6IDBcbiAgfTtcbiAgdmFyIF9TaG9ydFVuaXF1ZUlkID0gY2xhc3MgX1Nob3J0VW5pcXVlSWQge1xuICAgIGNvbnN0cnVjdG9yKGFyZ09wdGlvbnMgPSB7fSkge1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvdW50ZXJcIik7XG4gICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGVidWdcIik7XG4gICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGljdFwiKTtcbiAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ2ZXJzaW9uXCIpO1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRpY3RJbmRleFwiLCAwKTtcbiAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkaWN0UmFuZ2VcIiwgW10pO1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImxvd2VyQm91bmRcIiwgMCk7XG4gICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidXBwZXJCb3VuZFwiLCAwKTtcbiAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkaWN0TGVuZ3RoXCIsIDApO1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInV1aWRMZW5ndGhcIik7XG4gICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2RpZ2l0X2ZpcnN0X2FzY2lpXCIsIDQ4KTtcbiAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfZGlnaXRfbGFzdF9hc2NpaVwiLCA1OCk7XG4gICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2FscGhhX2xvd2VyX2ZpcnN0X2FzY2lpXCIsIDk3KTtcbiAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfYWxwaGFfbG93ZXJfbGFzdF9hc2NpaVwiLCAxMjMpO1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9oZXhfbGFzdF9hc2NpaVwiLCAxMDMpO1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9hbHBoYV91cHBlcl9maXJzdF9hc2NpaVwiLCA2NSk7XG4gICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2FscGhhX3VwcGVyX2xhc3RfYXNjaWlcIiwgOTEpO1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9udW1iZXJfZGljdF9yYW5nZXNcIiwge1xuICAgICAgICBkaWdpdHM6IFt0aGlzLl9kaWdpdF9maXJzdF9hc2NpaSwgdGhpcy5fZGlnaXRfbGFzdF9hc2NpaV1cbiAgICAgIH0pO1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9hbHBoYV9kaWN0X3Jhbmdlc1wiLCB7XG4gICAgICAgIGxvd2VyQ2FzZTogW3RoaXMuX2FscGhhX2xvd2VyX2ZpcnN0X2FzY2lpLCB0aGlzLl9hbHBoYV9sb3dlcl9sYXN0X2FzY2lpXSxcbiAgICAgICAgdXBwZXJDYXNlOiBbdGhpcy5fYWxwaGFfdXBwZXJfZmlyc3RfYXNjaWksIHRoaXMuX2FscGhhX3VwcGVyX2xhc3RfYXNjaWldXG4gICAgICB9KTtcbiAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfYWxwaGFfbG93ZXJfZGljdF9yYW5nZXNcIiwge1xuICAgICAgICBsb3dlckNhc2U6IFt0aGlzLl9hbHBoYV9sb3dlcl9maXJzdF9hc2NpaSwgdGhpcy5fYWxwaGFfbG93ZXJfbGFzdF9hc2NpaV1cbiAgICAgIH0pO1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9hbHBoYV91cHBlcl9kaWN0X3Jhbmdlc1wiLCB7XG4gICAgICAgIHVwcGVyQ2FzZTogW3RoaXMuX2FscGhhX3VwcGVyX2ZpcnN0X2FzY2lpLCB0aGlzLl9hbHBoYV91cHBlcl9sYXN0X2FzY2lpXVxuICAgICAgfSk7XG4gICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2FscGhhbnVtX2RpY3RfcmFuZ2VzXCIsIHtcbiAgICAgICAgZGlnaXRzOiBbdGhpcy5fZGlnaXRfZmlyc3RfYXNjaWksIHRoaXMuX2RpZ2l0X2xhc3RfYXNjaWldLFxuICAgICAgICBsb3dlckNhc2U6IFt0aGlzLl9hbHBoYV9sb3dlcl9maXJzdF9hc2NpaSwgdGhpcy5fYWxwaGFfbG93ZXJfbGFzdF9hc2NpaV0sXG4gICAgICAgIHVwcGVyQ2FzZTogW3RoaXMuX2FscGhhX3VwcGVyX2ZpcnN0X2FzY2lpLCB0aGlzLl9hbHBoYV91cHBlcl9sYXN0X2FzY2lpXVxuICAgICAgfSk7XG4gICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2FscGhhbnVtX2xvd2VyX2RpY3RfcmFuZ2VzXCIsIHtcbiAgICAgICAgZGlnaXRzOiBbdGhpcy5fZGlnaXRfZmlyc3RfYXNjaWksIHRoaXMuX2RpZ2l0X2xhc3RfYXNjaWldLFxuICAgICAgICBsb3dlckNhc2U6IFt0aGlzLl9hbHBoYV9sb3dlcl9maXJzdF9hc2NpaSwgdGhpcy5fYWxwaGFfbG93ZXJfbGFzdF9hc2NpaV1cbiAgICAgIH0pO1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9hbHBoYW51bV91cHBlcl9kaWN0X3Jhbmdlc1wiLCB7XG4gICAgICAgIGRpZ2l0czogW3RoaXMuX2RpZ2l0X2ZpcnN0X2FzY2lpLCB0aGlzLl9kaWdpdF9sYXN0X2FzY2lpXSxcbiAgICAgICAgdXBwZXJDYXNlOiBbdGhpcy5fYWxwaGFfdXBwZXJfZmlyc3RfYXNjaWksIHRoaXMuX2FscGhhX3VwcGVyX2xhc3RfYXNjaWldXG4gICAgICB9KTtcbiAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfaGV4X2RpY3RfcmFuZ2VzXCIsIHtcbiAgICAgICAgZGVjRGlnaXRzOiBbdGhpcy5fZGlnaXRfZmlyc3RfYXNjaWksIHRoaXMuX2RpZ2l0X2xhc3RfYXNjaWldLFxuICAgICAgICBhbHBoYURpZ2l0czogW3RoaXMuX2FscGhhX2xvd2VyX2ZpcnN0X2FzY2lpLCB0aGlzLl9oZXhfbGFzdF9hc2NpaV1cbiAgICAgIH0pO1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9kaWN0X3Jhbmdlc1wiLCB7XG4gICAgICAgIF9udW1iZXJfZGljdF9yYW5nZXM6IHRoaXMuX251bWJlcl9kaWN0X3JhbmdlcyxcbiAgICAgICAgX2FscGhhX2RpY3RfcmFuZ2VzOiB0aGlzLl9hbHBoYV9kaWN0X3JhbmdlcyxcbiAgICAgICAgX2FscGhhX2xvd2VyX2RpY3RfcmFuZ2VzOiB0aGlzLl9hbHBoYV9sb3dlcl9kaWN0X3JhbmdlcyxcbiAgICAgICAgX2FscGhhX3VwcGVyX2RpY3RfcmFuZ2VzOiB0aGlzLl9hbHBoYV91cHBlcl9kaWN0X3JhbmdlcyxcbiAgICAgICAgX2FscGhhbnVtX2RpY3RfcmFuZ2VzOiB0aGlzLl9hbHBoYW51bV9kaWN0X3JhbmdlcyxcbiAgICAgICAgX2FscGhhbnVtX2xvd2VyX2RpY3RfcmFuZ2VzOiB0aGlzLl9hbHBoYW51bV9sb3dlcl9kaWN0X3JhbmdlcyxcbiAgICAgICAgX2FscGhhbnVtX3VwcGVyX2RpY3RfcmFuZ2VzOiB0aGlzLl9hbHBoYW51bV91cHBlcl9kaWN0X3JhbmdlcyxcbiAgICAgICAgX2hleF9kaWN0X3JhbmdlczogdGhpcy5faGV4X2RpY3RfcmFuZ2VzXG4gICAgICB9KTtcbiAgICAgIC8qIHRzbGludDpkaXNhYmxlIGNvbnNpc3RlbnQtcmV0dXJuICovXG4gICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibG9nXCIsICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbmFsQXJncyA9IFsuLi5hcmdzXTtcbiAgICAgICAgZmluYWxBcmdzWzBdID0gXCJbc2hvcnQtdW5pcXVlLWlkXSBcIi5jb25jYXQoYXJnc1swXSk7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnID09PSB0cnVlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKC4uLmZpbmFsQXJncyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8qIHRzbGludDplbmFibGUgY29uc2lzdGVudC1yZXR1cm4gKi9cbiAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbm9ybWFsaXplRGljdGlvbmFyeVwiLCAoZGljdGlvbmFyeSwgc2h1ZmZsZSkgPT4ge1xuICAgICAgICBsZXQgZmluYWxEaWN0O1xuICAgICAgICBpZiAoZGljdGlvbmFyeSAmJiBBcnJheS5pc0FycmF5KGRpY3Rpb25hcnkpICYmIGRpY3Rpb25hcnkubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGZpbmFsRGljdCA9IGRpY3Rpb25hcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmluYWxEaWN0ID0gW107XG4gICAgICAgICAgdGhpcy5kaWN0SW5kZXggPSAwO1xuICAgICAgICAgIGNvbnN0IHJhbmdlc05hbWUgPSBcIl9cIi5jb25jYXQoZGljdGlvbmFyeSwgXCJfZGljdF9yYW5nZXNcIik7XG4gICAgICAgICAgY29uc3QgcmFuZ2VzID0gdGhpcy5fZGljdF9yYW5nZXNbcmFuZ2VzTmFtZV07XG4gICAgICAgICAgbGV0IGNhcGFjaXR5ID0gMDtcbiAgICAgICAgICBmb3IgKGNvbnN0IFssIHJhbmdlVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJhbmdlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IFtsb3dlciwgdXBwZXJdID0gcmFuZ2VWYWx1ZTtcbiAgICAgICAgICAgIGNhcGFjaXR5ICs9IE1hdGguYWJzKHVwcGVyIC0gbG93ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaW5hbERpY3QgPSBuZXcgQXJyYXkoY2FwYWNpdHkpO1xuICAgICAgICAgIGxldCBkaWN0SWR4ID0gMDtcbiAgICAgICAgICBmb3IgKGNvbnN0IFssIHJhbmdlVHlwZVZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyYW5nZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmRpY3RSYW5nZSA9IHJhbmdlVHlwZVZhbHVlO1xuICAgICAgICAgICAgdGhpcy5sb3dlckJvdW5kID0gdGhpcy5kaWN0UmFuZ2VbMF07XG4gICAgICAgICAgICB0aGlzLnVwcGVyQm91bmQgPSB0aGlzLmRpY3RSYW5nZVsxXTtcbiAgICAgICAgICAgIGNvbnN0IGlzQXNjZW5kaW5nID0gdGhpcy5sb3dlckJvdW5kIDw9IHRoaXMudXBwZXJCb3VuZDtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5sb3dlckJvdW5kO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gdGhpcy51cHBlckJvdW5kO1xuICAgICAgICAgICAgaWYgKGlzQXNjZW5kaW5nKSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZmluYWxEaWN0W2RpY3RJZHgrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGljdEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpID4gZW5kOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBmaW5hbERpY3RbZGljdElkeCsrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWN0SW5kZXggPSBpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpbmFsRGljdC5sZW5ndGggPSBkaWN0SWR4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaHVmZmxlKSB7XG4gICAgICAgICAgY29uc3QgbGVuID0gZmluYWxEaWN0Lmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gbGVuIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICAgICAgW2ZpbmFsRGljdFtpXSwgZmluYWxEaWN0W2pdXSA9IFtmaW5hbERpY3Rbal0sIGZpbmFsRGljdFtpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaW5hbERpY3Q7XG4gICAgICB9KTtcbiAgICAgIC8qKiBDaGFuZ2UgdGhlIGRpY3Rpb25hcnkgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uICovXG4gICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2V0RGljdGlvbmFyeVwiLCAoZGljdGlvbmFyeSwgc2h1ZmZsZSkgPT4ge1xuICAgICAgICB0aGlzLmRpY3QgPSB0aGlzLl9ub3JtYWxpemVEaWN0aW9uYXJ5KGRpY3Rpb25hcnksIHNodWZmbGUpO1xuICAgICAgICB0aGlzLmRpY3RMZW5ndGggPSB0aGlzLmRpY3QubGVuZ3RoO1xuICAgICAgICB0aGlzLnNldENvdW50ZXIoMCk7XG4gICAgICB9KTtcbiAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzZXFcIiwgKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXF1ZW50aWFsVVVJRCgpO1xuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIEdlbmVyYXRlcyBVVUlEIGJhc2VkIG9uIGludGVybmFsIGNvdW50ZXIgdGhhdCdzIGluY3JlbWVudGVkIGFmdGVyIGVhY2ggSUQgZ2VuZXJhdGlvbi5cbiAgICAgICAqIEBhbGlhcyBgY29uc3QgdWlkID0gbmV3IFNob3J0VW5pcXVlSWQoKTsgdWlkLnNlcSgpO2BcbiAgICAgICAqL1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNlcXVlbnRpYWxVVUlEXCIsICgpID0+IHtcbiAgICAgICAgY29uc3QgZGljdExlbiA9IHRoaXMuZGljdExlbmd0aDtcbiAgICAgICAgY29uc3QgZGljdCA9IHRoaXMuZGljdDtcbiAgICAgICAgbGV0IGNvdW50ZXJEaXYgPSB0aGlzLmNvdW50ZXI7XG4gICAgICAgIGNvbnN0IGlkUGFydHMgPSBbXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGNvbnN0IGNvdW50ZXJSZW0gPSBjb3VudGVyRGl2ICUgZGljdExlbjtcbiAgICAgICAgICBjb3VudGVyRGl2ID0gTWF0aC50cnVuYyhjb3VudGVyRGl2IC8gZGljdExlbik7XG4gICAgICAgICAgaWRQYXJ0cy5wdXNoKGRpY3RbY291bnRlclJlbV0pO1xuICAgICAgICB9IHdoaWxlIChjb3VudGVyRGl2ICE9PSAwKTtcbiAgICAgICAgY29uc3QgaWQgPSBpZFBhcnRzLmpvaW4oXCJcIik7XG4gICAgICAgIHRoaXMuY291bnRlciArPSAxO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9KTtcbiAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJybmRcIiwgKHV1aWRMZW5ndGggPSB0aGlzLnV1aWRMZW5ndGggfHwgREVGQVVMVF9VVUlEX0xFTkdUSCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5kb21VVUlEKHV1aWRMZW5ndGgpO1xuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIEdlbmVyYXRlcyBVVUlEIGJ5IGNyZWF0aW5nIGVhY2ggcGFydCByYW5kb21seS5cbiAgICAgICAqIEBhbGlhcyBgY29uc3QgdWlkID0gbmV3IFNob3J0VW5pcXVlSWQoKTsgdWlkLnJuZCh1dWlkTGVuZ3RoOiBudW1iZXIpO2BcbiAgICAgICAqL1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJhbmRvbVVVSURcIiwgKHV1aWRMZW5ndGggPSB0aGlzLnV1aWRMZW5ndGggfHwgREVGQVVMVF9VVUlEX0xFTkdUSCkgPT4ge1xuICAgICAgICBpZiAodXVpZExlbmd0aCA9PT0gbnVsbCB8fCB0eXBlb2YgdXVpZExlbmd0aCA9PT0gXCJ1bmRlZmluZWRcIiB8fCB1dWlkTGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgVVVJRCBMZW5ndGggUHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KHV1aWRMZW5ndGgpO1xuICAgICAgICBjb25zdCBkaWN0TGVuID0gdGhpcy5kaWN0TGVuZ3RoO1xuICAgICAgICBjb25zdCBkaWN0ID0gdGhpcy5kaWN0O1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHV1aWRMZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IHJhbmRvbVBhcnRJZHggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBkaWN0TGVuKTtcbiAgICAgICAgICByZXN1bHRbal0gPSBkaWN0W3JhbmRvbVBhcnRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcbiAgICAgIH0pO1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZtdFwiLCAoZm9ybWF0LCBkYXRlKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlZFVVSUQoZm9ybWF0LCBkYXRlKTtcbiAgICAgIH0pO1xuICAgICAgLyoqXG4gICAgICAgKiBHZW5lcmF0ZXMgY3VzdG9tIFVVSUQgd2l0aCB0aGUgcHJvdmlkZWQgZm9ybWF0IHN0cmluZy5cbiAgICAgICAqIEBhbGlhcyBgY29uc3QgdWlkID0gbmV3IFNob3J0VW5pcXVlSWQoKTsgdWlkLmZtdChmb3JtYXQ6IHN0cmluZyk7YFxuICAgICAgICovXG4gICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZm9ybWF0dGVkVVVJRFwiLCAoZm9ybWF0LCBkYXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IGZuTWFwID0ge1xuICAgICAgICAgICRyOiB0aGlzLnJhbmRvbVVVSUQsXG4gICAgICAgICAgJHM6IHRoaXMuc2VxdWVudGlhbFVVSUQsXG4gICAgICAgICAgJHQ6IHRoaXMuc3RhbXBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZm9ybWF0LnJlcGxhY2UoL1xcJFtyc11cXGR7MCx9fFxcJHQwfFxcJHRbMS05XVxcZHsxLH0vZywgKG0pID0+IHtcbiAgICAgICAgICBjb25zdCBmbiA9IG0uc2xpY2UoMCwgMik7XG4gICAgICAgICAgY29uc3QgbGVuID0gTnVtYmVyLnBhcnNlSW50KG0uc2xpY2UoMiksIDEwKTtcbiAgICAgICAgICBpZiAoZm4gPT09IFwiJHNcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZuTWFwW2ZuXSgpLnBhZFN0YXJ0KGxlbiwgXCIwXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm4gPT09IFwiJHRcIiAmJiBkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZm5NYXBbZm5dKGxlbiwgZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmbk1hcFtmbl0obGVuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogQ2FsY3VsYXRlcyB0b3RhbCBudW1iZXIgb2YgcG9zc2libGUgVVVJRHMuXG4gICAgICAgKlxuICAgICAgICogR2l2ZW4gdGhhdDpcbiAgICAgICAqXG4gICAgICAgKiAtIGBIYCBpcyB0aGUgdG90YWwgbnVtYmVyIG9mIHBvc3NpYmxlIFVVSURzXG4gICAgICAgKiAtIGBuYCBpcyB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBjaGFyYWN0ZXJzIGluIHRoZSBkaWN0aW9uYXJ5XG4gICAgICAgKiAtIGBsYCBpcyB0aGUgVVVJRCBsZW5ndGhcbiAgICAgICAqXG4gICAgICAgKiBUaGVuIGBIYCBpcyBkZWZpbmVkIGFzIGBuYCB0byB0aGUgcG93ZXIgb2YgYGxgOlxuICAgICAgICpcbiAgICAgICAqIDxkaXYgc3R5bGU9XCJiYWNrZ3JvdW5kOiB3aGl0ZTsgcGFkZGluZzogNXB4OyBib3JkZXItcmFkaXVzOiA1cHg7IG92ZXJmbG93OiBoaWRkZW47XCI+XG4gICAgICAgKiAgPGltZyBzcmM9XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQU93QUFBQkhDQVlBQUFBRUNLczVBQUFMeFVsRVFWUjRBZTJkZCt3RlJSSEh2MVlzR0h0WFZMQmpWOVQ0anczRkFvSUZ1MkpIN0FSRmpTVnFVQ0ZvN0NJSUtLaW9NVXJzTWRhZ3dkaU52VGNzMkxDTFhlOFRiOGxtMkwzZi9kN2V2dHQ3djVua1plL3UzZTdPZlcvMmRtZDNabFp5Y2dRY2dWWVEyRVhTelNYZFg5S2hrbzZRZEt5a2QwazZUZElwclREcWZEZ0Nqb0IwcEtUL0R2eSs2eUE1QW81QU93amNwR1BsZVpLTzdudlR2NXJHKy9wMldIVk9IQUZId0NMd0VkTmdIMlJ2OEhOSHdCRm9BNEh6U3ZxdGFiQlhib00xNThJUmNBUXNBamMyamZVNzlnWS9kd1FjZ1hZUWVMSnBzTWUxdzVwejRnZzRBaFlCbG5MaUdXUFhYeTFDZnU0SU5JTEFlU1Q5MmpSWTExOGJlVG5PaGlOZ0VYRDkxU0xpNTQ1QXd3aTQvdHJ3eTNIV0hBR0xnT3V2RmhFL2R3UWFSY0QxMTBaZmpMUGxDS1FRY1AwMWhZcGZjd1FhUldBdCt1dDlKUjBtNlRHU0hpN3BRRW43UzlwN3hHKy8vdjZEK3Z5NEZaRi9ET0dLZExpa2cvdTg1T00zcHQ1OStuc2YyT2Q5Z3FSREpGMWlUTVYranlOUUNZSHErdXR0ekhwUnZOaGJjanltNGRpMXFwTDZRdDRIVjNvUlhxd2pzQlVDYTlGZjk1VDA2YzdwOWx0ZDcvcGpTV2RKT251YmpmZ2ZmYjRmU01KbUVxZmRyWWlIZTYra3IwajZmbThvL2NkdDFrc2poZDh6K2pJK0pza1hxTGRDM3YrdmhjQnMrdXY1SmQxVTB1a0REZWl6a3U0aWFkZUpuLzdxa2w0MlVDOGVFSStXZEtXSjYvWGlISUZTQko1aTVIYnQ5c1BQTnd5RVllZHZ1a1oxOGRLbkc4aC9pMHk5MUgvWGdYeitseU13SndLbkdybGR1LzN3V3cwRG9jSFcvbkl3a1JUcWl0TXpKZUZuNk9RSXRJWUFja2xIRnN2clZkZk41QThOQTRFWlpwQnIwaXN6OVo1UXMxSXYyeEVvUUlEd01LRjlrSzdkLzNVM3cwQmc1dCtTTGxud1lHT3lNaEVWNm90VG53RWVnNTdmTXdjQ3MrdXZyTWZHalNVY2Y2RXlHcGVXeEVjaDFCZW5mRVNjSElFV0VaaGRmMzFqcHRHOHRESmE5OG5VNnlFaUt3UHZ4YStNUUJQNjY0OHlEZWNlS3ovV3VJeXZ6dFRySVNMSDRlZDNyUitCMmZYWGEyUWF6VHIwMTY5bDZsNzdGUG42Mzd2WHVGQUVadGRmSDVGcE5MWDExOHRKK2srbWJyZGdXcWcwN3dDMlo5ZGZUOG8wbXRyNkswNEk4U1JUT0Y3N0ZQa09FREoveEdrUVNPbXZWMGtVZlUxSkYweGNuK1RTWFBycmF6TU50cmFoeGlTZ2VTRTdFZ0ZyUDV5YUhLV3hNbko4VkEyRWRzODBtblhvcjkvTTFPMzZhNDAzN1dWT2dZRDFmMDFOamo2MWwrdTlwcWpRbHZISVRLTngvZFVpNWVlT2dIU3lhUzhQU1lEeXlkNXM4WHlKLzRvdldRYUNIbGxiZjJWUHpWQlhuTHIrV3Z4S3ZZQ0tDSHpZeU8wTlRWMlhsZlN2enJ1c21scUhUMnpjWU1KeDdmWFgxMlhxcmZhZ0JsZy9kUVJXUWNBNnlGelJGUEtNWHE1dmJhNVBjcnBIcHRHc1EzLzlkcVp1UEhlY2RqWUNMT25SRUVvOXRaaWxwYXlyVGVqSGJVMTRieEM5cW90MTRZOSswWVU4K2xSMGJkSkRackZDanhxbnRmVlhYa1pjWDN6czY2K1R2dUxGRklaTU1McjZVeVFiaEJSaVVvZUowVEYwWVVrUDdUZFgvbGxVVHBDdlgwcDZXNkdQOVFVazBUNUNtYXgwOEdIQkp2NkRrdjR1Q2YvdUt2U21xT0xBQUdsdC9UWG4vMHF2NjdUekVMaFdGMVdFQnNiSTd1MWQrcHcrRFRMNVowbjNHNENGbnBTaEtBMlNQT3lFL3Y3T3krd1ZrcDdWNVdPWDlJOGFXVCt0NzhVSGlzMytoY0hQaDZMeWZ0YzNWRDQyMkJaVW83bjBWNzZhNFdYRTZaallVTlhBOElKblFlQ2lYYTlJYkxDL1NMcWQ0ZURJU0U3K0tlbE81bjlPbWZRSjdwbGY3eHYyUlJMM2NRbEhFOG9KTW9mOFh6NXo3NWpMdCtvbW1KN2R4elFqWmVoZGpWamNEWXpINlRyMFZ4YWI0enJEc2V1djFWNTNzd1cvdUplRmh5VTR2STZSRTRMMzdSTGRkM2RKQlBKakdQcEVTV09XVVd6OHNBOUU1VFY5U0dDejBGRGl0TGIrU2pDMXVMNzQyUFhYcGtWbWN1WllBdm1icEM5S0lxcW1wUXNsWk9XZS9VMDBWaG9xdytEdHpNZ3lTUlRMSE1mMGxNM1RteE9Ndy96bnVyQ25UNi80eS9uZHV2N2F2TWhNenVBemV4bk1tZkF4d1dPZFE1aVlvdEdoMXhKUjgwYmI1SW9Jb2F5VHhvMjI5cHpOTmxsTTMvNVR3M1Q4QUhNY0wwbC9KWkxqdTd2WnhzOUkrdnlDZjh4cVBpNHRIdFd2MHFNU1ErejNrdEJqVTRSUnZaVkZSb0FZMXpEQnMrcHM3TTlOdWNUcGJwcVlsYk5BY0U2QThOb0NhTDl1Z1k4bDZhKzVOZVR3TEV0SzZjRXVOWU8wM3JLWHdaUXRibUNIU2FZY2xpemZyRW8vTWVYaS9OSTA1ZlRYajFmbWVzai9kVW1Cd25OV1dqbmhhdm42bDh4RVRtVVJPS2Y0TU5sMHdEbFh6bjN3Tk5Pd0FvNm9jeVhFc2s4b2l4UmpoNmJwTFliaHdEenJWVFVwWnovTXRpRkxveXYwK2hNYmZDM3hkek5KeE5GTlRmYXM0MTE4dVIvUkRRV29mMmRDVHRGYkwxUEFZR3JTODZzRjVhMGxhMDUvdGV0Z1V6TnpUT0lGOExHZ3gzTGFPUWl3Y1JyTGgreU5ORVJXMTBSV0hqK1VZY1IvZDA3SUlFWVd6ZEsxRXd3REJOUHJtSGJWcEc5azZuNUF6VXE5N09ZUTJMZVhneWNOY01hZVMySGtGMUtHcnFWUkhEQndDT1dGbE9GNXM4U2VzSUhST1AxRVpZNDNSWCt0RE5PT0tCN3JKR2JacmFkTC9QQXA4MVZjUVV1SlhqMldlNDd2WFZwb3pmeW5KQmlHYVRiQ3FrbllnbHFnT0YraS9sb1RKeS83L3dnY241QVhnZ1dXRUNhTGpDUmpPV1RWWW81Wjh0SFBrZkppNEFIdU1McUUxVzdNeFc5eS9YVTFQRGM5Ri9iRmNjUGllS3pYVGc2YmxQN0tXbnF6WkcwekF5Q1llT1VNcHFkNkdBeXpRMzF4eXN5eGt5TVFJNEFSZlN3akhMTjJXa3BISmNvOW9yVFFtdmtQVGpBTUdMZ2ExU1RYWDJ1aXUzbGxwK0tNVGFHL0JxK2UrR053MjViaHMrRXRBdU12cU14MEx2NHdVUk9kSEFHTFFNcE9vRlIvVFkwdThXTXRuWFcydkU5Nm50TmY3emhwTGVjdTdEV1pucDExV1NkSElFWUFRdzZXYjBKbkV0SlMvUlZIOWxCV1NOOFFWOXphOFhVVERNTTQrbXZPK0hxcVozRDlkU29rTjcrY1BSTnlPb1graWd0ZmFLZ2h2VnZMY0Q0MndUQ01Wd3NZMVlPQno2TjFrUXFBTGNsK3VPVjN1MG04NFlnZTVDT2tiQ1ZUUW16MlptV3crZUV3d2FjQ0FIRmFlNWJzd0V5OVM5WmZjVW5ETmV5c2hmOHcvV083ejVZb1pUOWNxcjhHdjl0WTdwc2VEdk5DY3ZwcktrN09sQzh3dC8vcmt2WFg3MlUrUXJGQUxPbTRKSzdSbExLQy92cXJCTGFsK210cVM5Tjl0bUI4MXduQ3JHNVJSZjd2NnlWQVFLQUlTRVVzMVpxVUFvdTZoNkxnMWVSbmlyTFpPNFVoMVpJYVpZcFgzTXl3ZkN1Ti96c0ZwcFJ4L1FTbVp4UVdiamRmQmdjbXRZZzhrU1BpUnZIaGVIbnVodHJYRDBrQUFlT25WNjdZOWRmS0FHOVk4U2s1WlltbmhGNlNrSDBDc1EwUmNhTm9IMnpjUEFzUjZ6WDFoWDFSWlc0SUs1bXFGNjhkSjBmQUlwQ3lFOERZWjFWaTVKQnlKY1YvZVlqQ09uQWMxWC9vL2tuL1F5ODRNOU53dGhySGx6THlxa3k5MkJVN09RSVdnZFE4Qzh1UnE5THRFL0szMVdRbmtSci8wTVV3UnBXYmhWSjZBYjNlT3ZSWFBQbFRQZXlTOWRkWlh1SU9xRFFWSjV1T3BpUWlScXJEWUZlQklTSldGRExMUE1Vc3hCSkVxdEhVamhUSFhpTkVGYkIxc3g1R2VCVW5SeUJHNEtDRXJMd2p2bUdGWS9acHRmSkhBSWNoSXN3dlBTeFJNV2FoVXhOTTh4QjRMdFNrZTJYcWRmMjFKdXJMTFp0NHc3WnhsWWFESWNCY1hDYnJ6a05FUURqdVo0dVFXUWlYT1FJdXgweUg0OXBoV2JCT0NYWEZLUk1MVG82QVJTQmx2b3JCZmduRkcxWWhnMnpHbkNQTWM5bENCajE2S0RCY0x2OGsxNC9PTkJxWTMyK1NHdEtGN0cwMkhZb2I3RkFjMm5ScGZuWFRFU0RpZ3pVZG5NSitHSDAxbGoxV1MzSjBZbjl2MkFva2QxL3hkZUxqMEVBd0FXU3pXUUpiRVZUS0RnZGl4am5tUzRJWERUb3VpamI1OGNnbnlQZ1kycTNiMW9QOVRjakhKQksyeWl3VHZTK3hGVUpjTjg0RzlMS0hTY0x2a2Z5VXcvNG9yU3pnajNsK3YyYzZCRUpRdGxoT2FFQ2x4TTRCY1VnWWRGcExUR29GeDNiV2JLc1MwZFB0bHlsKzZGV09lY0F4TTNPcEtmaFY2b3Z6MUY1bXF2b3l2UENWRVhpaDZRbVJpYWwyZ2pnMEtodlpqdmZpd1FvcURKdFBHQ24zS3o4a0dmZnE5OVhrQVRHVnd4aWRMZm0yODhNRWkzeGhDNDMzak9DSW5wRDlUYWlYZlQzSnp4Qm1PL1hTNE1sM2RsOE81KzY5TXdMOERiekZldWlnUzA1cE1zdG9MdlMwalBCd3RRc0dGY2d2bTcvNTZHNERCY3NmcVE0Q1JIMWdaaFpYVDR4cWFqZ2pFT2Y0dWYzTzdBUmVvMk02Zkl0UXE4VlArejhZZTltMnBaRXNOUUFBQUFCSlJVNUVya0pnZ2c9PVwiIC8+XG4gICAgICAgKiA8L2Rpdj5cbiAgICAgICAqXG4gICAgICAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYEhgLlxuICAgICAgICovXG4gICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYXZhaWxhYmxlVVVJRHNcIiwgKHV1aWRMZW5ndGggPSB0aGlzLnV1aWRMZW5ndGgpID0+IHtcbiAgICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUZsb2F0KChbLi4ubmV3IFNldCh0aGlzLmRpY3QpXS5sZW5ndGggKiogdXVpZExlbmd0aCkudG9GaXhlZCgwKSk7XG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogQ2FsY3VsYXRlcyBhcHByb3hpbWF0ZSBudW1iZXIgb2YgaGFzaGVzIGJlZm9yZSBmaXJzdCBjb2xsaXNpb24uXG4gICAgICAgKlxuICAgICAgICogR2l2ZW4gdGhhdDpcbiAgICAgICAqXG4gICAgICAgKiAtIGBIYCBpcyB0aGUgdG90YWwgbnVtYmVyIG9mIHBvc3NpYmxlIFVVSURzLCBvciBpbiB0ZXJtcyBvZiB0aGlzIGxpYnJhcnksXG4gICAgICAgKiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgYGF2YWlsYWJsZVVVSURzKClgXG4gICAgICAgKiAtIHRoZSBleHBlY3RlZCBudW1iZXIgb2YgdmFsdWVzIHdlIGhhdmUgdG8gY2hvb3NlIGJlZm9yZSBmaW5kaW5nIHRoZVxuICAgICAgICogZmlyc3QgY29sbGlzaW9uIGNhbiBiZSBleHByZXNzZWQgYXMgdGhlIHF1YW50aXR5IGBRKEgpYFxuICAgICAgICpcbiAgICAgICAqIFRoZW4gYFEoSClgIGNhbiBiZSBhcHByb3hpbWF0ZWQgYXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSBwcm9kdWN0IG9mIGhhbGZcbiAgICAgICAqIG9mIHBpIHRpbWVzIGBIYDpcbiAgICAgICAqXG4gICAgICAgKiA8ZGl2IHN0eWxlPVwiYmFja2dyb3VuZDogd2hpdGU7IHBhZGRpbmc6IDVweDsgYm9yZGVyLXJhZGl1czogNXB4OyBvdmVyZmxvdzogaGlkZGVuO1wiPlxuICAgICAgICogIDxpbWcgc3JjPVwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFNMEFBQUJOQ0FZQUFBQUZET0N4QUFBUDVrbEVRVlI0QWUyZEJkRDBTQkdHWC94d2R5amMzZUhna01MZHBhQ0F3NzF3T2VEUVF3cDNLZHdLZDNmbmNMZkQzZDBkOXZscittZHUvdG1rSjhudXQ1dXZ1eXExbTJReTBobHBlWHNpQlFVSFZzT0JrMG42dktSRFozaXNobU9SNjY3bndDMGwvV0hCaFlmTThOajFMemNZc0JvT1BGL1NtMWFUZGVRYUhKZ25CNzRoNmI3emJGcTBLamd3UFFkT0t1bS9rdmFmUHV2SU1UZ3dUdzVjVjlMZkpCMXRuczJMVmdVSHB1ZkFFeVY5Y1Bwc0k4Zmd3SHc1OENsSmg4eTNlZEd5NE1DMEhEaW1wSDlLdXZLMDJVWnV3WUg1Y3VCeWt2NHQ2WGp6YldLMExEZ3dMUWR3Wm41dTJpd2p0K0RBdkRud0hrbFBuWGNUbzNYQmdlazRjR1JKZjVSMFEyZVdSNUYwV2ttbmR4NG5jT1lieVlJRFc4T0JDeVduNXFsNmFzeGdlWXlrUDZmME9FSTl4MzhrbmIwbjc3Z2RITmdxRHR4RDBuZDZhbnhFU1crVzlEdEpyNWYwN0hUOE9QdlB0Uzh0QnNpcmltdjNrY1NBQ3dvT3pJWURyMTJJV1MvdWFjMkRKTDFCMG9teWRHZVI5Tkxzbkw5dmw0VDVPaWc0TUdzTy9GVFNiVHRhZUE1Skg1QjAxQ0xOUVpJSUpUQmlOZnE0bmNSdmNHQ3VIRGh6MGt1NmRJNERKQUhtTE9tVGtrNlhYVHlucExkbTUvRTNPREJMRHR4SzBxOGxzVXEwMEdra2ZidDQ0RGFTbmx0Y2k5UGd3T3c0UU5BWnVrb3JIU3pwZWNWRHo1UUU2RE1vT0RCckRoQjBkdS9HRnJJcWZWZlNUWXJuM2lmcHljVzFPQTBPeklvREZuUjIwY1pXWFRIcFFhY29uanRzb2VPOHFMZ1dwOEdCV1hIZ2VwTCtVckdLOVRVU3N6TCttSkt3d2tVOFRzbVZPSjhWQjlBLzN0L1lvck5Kd3NQL3VNcHpPRG94S2h5cGNpOHVKUTRjWXhFZWU3OGQ1Z1lpeGgxMnVBN2JXanhCWnc5cnJEeGVmNkF6aEJLVTlJVjA3MkxsalcwK1ArRUNDbkVCU1RRS3NGMnJtVEZ2KzdFa3ZYc0o4L0owNi9pUEplY0o2eWhvUm1Ydy9nZzZRei94MG5HVE9QZXpSWVFuSU0rU1hwa0d6Y1BMRzl0MmZzcTBHdUNwQlRzRTRJN1lDZkJCNEkyZXNzQUpuYnl4VVF5Mk4vWjRrZk1zcjVBNjlhTWwxWTVINUlrWERqSUFoSWdPdGJSY1k0RHNWendEbkFNTVZaQ1BBNWVYOUs4Rm54a0lYanAxOHMzY1pja0RyRDVZMWNoN0RMSEJCK0xmc3ZkLy95THp5L1QwTC9yOEVZcG5xcWZnZjBqOEswbjNXdnhIbENvSjZ3ZHhGT3lvZUxYeVpzYzVnKzR0SGZmTFczaWJieTZKeGdKQloza0hLVXMrdDZnd0dkajVUUmV6R2tBLzVHVFM4NElmS3dsbjNOVXJxeVF2bnhjR0E0UDZPUUR2UDlPZmJFZFNuRi9TZ1l2My91QzBHdkwrZjVQNkQvM29ra1d0d01EZExDME92MDM5aFYxMVdQSG9YMWNxMGxkUE1TSFNnV0FLSGJDTG1MR0JROUFwTDl1Vk1OMURFYVRqOStWYnk0b1ZDcFFzVFBBNndiRFNrUDUxdFF5TGEvZ052aGxiRUJWY3FaOHlXVzY2VDRXSm5uN0oreTlYbDNxckpFUkgwcU43dWVrcWFSYi9xS1JqTzUreWVBcE1objBJVlpqOURHZStaYkx6cEFiUnFLdVdOeXZuQkM4UnQwNzZPMWJ1bDVjWWxGL1pBT05FV2E5Tk83ZWdzK3R2V3NXSytpRHU4ZTQ1TGx6Y3E1MmVLVXZ2Ymh0aXl6K1MzTmthTGZmWlZPRGRhclZKMXpBaTBBQldteUYwMS9ROHM0ZG5BNGRyWlV6d2xvbThqYmlKb2h0VTV3QWRrUGRZT2lmcnFYZnVLdUlWOWVSOTFnd1BaYzNBdnBFZWszZ05ZRnFtRjNJZG9nOGRzdFhEUzJZczFSVDQ0WDF5L3Y4RmxPMHgwRzlFTE1wQUhQVFFrMUw2bjNzVnVZVmhnOG1DaVNPSHJIdksyazFwTUpoOGF3c2FURitrdjNpUjB5OUw2V3VPMTMyYXl6YWlpQ1VVTUJUR2NNLzBQQjJ1TnFvUjlWQ3VIckJQNmI0TFdDOSttY3JBUU9FaHMvdS93cE00UzROWEd2RjBLaUxxa0VrSk0zMk5ONTV5YW9ZWXozT3JTRVBRMlF0WGtmR0VlY0l2K2h0OUdvT1FoMzZVMHJzMkNHSG1JUE8vRi9FTm5vSXN6WjFUSHVURGgzMUt1bWE2NzVFdHkyYzVINlBQdERvdkg1aVc2QlBYS3RKd0RZc2NKdm5mWjd6NVU0cHlaQkMxMEpTRHVLWGNNaTJURnl2M3Jjc2JHM2JlcXMvd1B1aTdITUNET2duZEFPZ0NpY2ZNSG14SGFvWG1nVVZXT0xCdlZxR2htMk9qSzVHL1Y1KzVUbFlmcno1amRjWEVTRm5vUkVNSk1lL0xLUjhzY2pqdVdQNi9tSzR4UVQzS1lUaWhmSHhsbU00M2dheHpuWFVUS3ROUkIrdVBYbjNtZHVtOW9NK2NwQ1BmUGJlc005SkpXcnk3WmI3RVZkaWdxVm5RMEdYb1JFT0p6UmpJMzZ2UE1NT1R2a1dmc2JxeFV2SXNmcDJoOUpMVTBUR3VsSTR4VnMxM3BUSitJT2tHSFlYd0xIa3g2RGFCOEhNaEpwZHQyb1M2NVhYNFNPS3ZWNTk1ZVVydjBtY3NjeGd4Vk42bXNuUm1PaHJPMEpKZ01FWUdFQVZEQ0ZPd3JZWmZMM1lxc1YxTnlsOXphcmJxTTlTUCt2NDFvUmFHMUJlNEVmSTBnNk9MV0EyL2wvajIzdVRub3ExRzUwdEtMSEFWTEkrYlFFeU9IcC9YVHRZVmZZYVZuUDdJOXovTHZsRTd4L2xKK3FmMVZSejRpL2t4WHQyWHVPTStsVVQwb2xCV2hKSXM3dUk1NVEzbitYbFQzdVNQdm9FTnZldXdwWmIwcmZxTVZRbnJFSWFFSVhTcGhLdnpQQXZ2RUNWTWFVV2NZRVcyU1FLKzRwWGVGRUxVeE9penlRUU1oM2ZQZ1F1aHE2OXdqeUE2Uzkrcnp3QjlzY1JlQzBPTldhYmtrMWV0azlybUMxNnJWMW5HM1ZNOTZVQTEwYTlNZisyc1hVTmw3MDhuMGE3TTIzUE9CaEd0Nk8wekxKekpqMDlXVEdKVVdDblJnWmd3cGlaMHBDRmtrOTlGaGp5OHhtZkFJdElYbVhqeWxYdFpGZGhKaC9RdWZRWXZ1UTJhTWZvTWUxNlJEL0NZR29BUExCRDNXMkhrMWtoaTBIbmVhMEVhNHAreHN1d1hzWlgyekkzT1BVSS9ZaFlHODFkdXhkVEZJeVl0VnY0cER1OEVRaitodjlTa25scGR6VCtEa2FhWHpMZENBZDRLbFpsaWFXQm1KQStVN3hyaExPVStJTDlXWXFaQVQrTDVFczI4TEMva1dOS2ozQTBsZ3F2UWE4WVMxaWJRdGlpazZIUVlGeTQ0SUZOVzI3RUVMdzlkb010L01qQWo4SDdvWGkzRS9zN2dHS2M0YnU4b09OZG51dEFwZVZibW4xbldmL08wZTJSbE9oY0g0c0VRWXZYZ2VUbzJDbkNObU4xSWc0bTFsVkNHclk2RUNQUlJqamZ6TUhsWmZuUXVqQ05qQ0ZuWkFJUFdCdnZscytFNE96MkVjeFFnNFZneWZ4eDE2TnQzdVZZV0l1dERhemMyNkJwOXhIaE0zK21qSEc5R1NFRXZvYkJhQVJmdlRiMXZBcERLT092SUE4ajFNc0p2UTVvaHFGalRaN0FnZVFDa09kNXNxRDVET3pBQzlPMVB2S3k5WEFkcVRwc3hMUU11UlI5Z1M5WkxwNzI5YUE4ck5QRDFvM2RsbEhadCtVUlBtcjdidkN2YVkrL2IxVUd5VEMzb2JHeXNTNWJsU3Y0K01yVVJhNjBuYkRySG0vWDZaNmd4amticjlNU2ZsTVJNeUd3TlpMNTBTbUtXWllNRVhrSWZhcG1aa2hsM2lLK0JZRFhLK0ZoWnVTWG5pQkNrQjNFOXhwZkF6STVlTTRSNFdTanlYZUlveGdKRVFPcEtaOGFZVWlNY3JYU0FPOVZ1Tmx6RDlKNVBrcTFHR1FhTGQrSnFxTmJrU2VrbjhKUis0eUh3a0tSMzZUT1dJVGdiSGtKY3lBbUgyN01XUVdhWFdNeTZXS05LY3pHeU9jK0JRL0xzNlA3OUJrWGU2b0VNYnZaenIyakgxN2lvMXhoOUJrVVhVM3paWnF0WDN5K0dEMHpXbnBudVJtbUFVV2NjYTh5VUtNMXNHRzZBUXdhWGg4Zkw2blhqeGNBeitkNzhWNjI3dmpBQnNDZkFKaE9yb2JrK3ZGRzRPSmZodlV1ZnNjWUQ3MFoycHpDVHNSRWx5dTFCTVJxd2tUV3pONkJMQ3NMUjVYV0lNaWd4QWJhUVdkMG95eE05ZC96TTcwVEhHMHJuU3UwYnFud1QvVm51SHRsVkY4Uk9abjVXRk5wcUJ6TTc4Q09VMnpGRTNqYUFEVm1CaE9GOWQ1Uk5IQlJXeVUwbTIwOE4vbm1jd1dmTWVOMHFydTZKdU1TVWlQTExhR1dWS1lPOGdJUGdlOEQ4Q3dBUm1iMkZDSm1tTWV6aDZ5V3NUdGFCR01oOXhFQ3g5QVRHRFNWRVZmTHhLSksxTXRCUlVEQmJpZWNBR2hLV2dOUE4wK2JXTW5pSHhpT3Z4WlRCaGZtOXVXTzFWbTVrZWlZcTJvYVU0SmtRY0pRYkw0WkVFdTh4ZytLSi9tcXljdEhKalZEa241NXM5R3hLVWFLWWJSYXo5TFZmekt4VXNOeUt0RXhMUTlpbHhzQ08xaWlXVWNTVk1td1ZYeE9pQnVsaGxxVkhKOEZlUDJSMlJDekRMRHRHSnlyYnRTbm5ySUxHSSs5cWJFRm5yUnVvcktQTmJLQkJmMkY3WEdzWHYraUpINnBFN05KL3VQNjFJajFtWjNUWVp1c2duUi85QmJRekNoV1dINVI5OUFOMEY0Q0ROY0lDNUdFb01Udkw4ckI4R2FETWdJaUsrWUZKbkNXM2pCYkV1NDBZbDZlMS8xeXZJYTZ0ckdXLzRNR1lKT1pJaUlKbUJrZTg5aEQ2QVoxeUZVU2ZvKzk0TEtPMThsblJ3ZmpaTzdkZlJDLzZTMmtSUTlKQmdyQjArUy9waDVqaWEvWGFjdzJkcG1aTndqZmpkWGlSQjNMN1dCbDlhU1VudUlIcG5aa0t2V2F1Wkp1Tk1JbDVDSUNtZDRCNThpTU5IUmNMRjFaTzZvRjZnTEVJNitkUW1JKzM3TFdsd3h1UFlwclA5Q2plNkVIQXhUMkU0eEZyV0tzKzVNbDdxalF2YUpnRXBpcHozZmtnZmpJeGdMWHEyMnNCRVpYd2lpbkR2eEhSc2NUbHZrRXdoWWhPcklKc28rUXgvS3liYjgzbG1Za1puWWZHQVM0RUJZQ3UwZWVjeXdzandoUDl3d09reTU5YngzK1dicUF6UTZOTDExSEhLY29nNnRMa2Z3d1BYV1JCWjRCdXB5QkVJTFlHcTJFVXlkL2l1M0Q4Z2lUWmFzb1piUXhuNVduMUVHUFZBQnUyU1hCM2V6RUE5MXp4NGZiQWx2NmFTWjMzMkxkbkExTEVMeVkwaXJ5dFowTkdKbE8ra0ViZDNyR2wvTjFiYlVRclpFNGJNUGhjZW1NUDlqNTkrRC9BV3dEdzVhTGU0Vk9zL3d5VE9vNVJUK2pCK21zM2JZbDBUTnUzb0hScWx5VWhycjZtdkRqdy9EZ0pnWUtVMG1YaU5WUUhvdG95UE9QQUtxei9NUnFOLzRBNEhQU1pNWVFmQ0ZOeGkyZzNwcnl1WjdIQW9CeTMrSkM2OHR1R2V3YmhRVi9wSW9MT2hqcDV5M3lCRHRtazJ6VllnUXhadWsyUDNTbmJ1UEp6WnZjU2ViRHlRb3NDbUFnUUF6QlI3aWJLSGNmTFpuMmNxM1RlSWFFTU5WN2FTa09lWGU4OUQxblp2NWJSYnI4RzhuY25pWlZ1TjRoa0pZL3o2RlppWG1xRStOMEt0Nm5sazE5alp5Q3djRjBTQnRBaEJoYld2YkhiYU9WbHgvL2d3Q2dPNEZBMEVXalp0M2xBVStCdFh5ZmxoZ0R3YmtIQmdZM2l3QS9Ud0ZrV2RrSFFHV2lQZFpLQkxySE1qc0VQcnJQT1VkWXU0Z0E3RUxIYTRKc3E0LzR0Nk16eitaU3BXR2J1Q09yRVp2ZEJ3WUdONDRBaHorbWtwYkp2UVdjTW5uV1JoWng0OTRKWVY3MmluT0RBWGc0Y2tPazFaV1FvYU4reElkWjdDM0w4UVN6REw0TnplWTdvY2djTElzazJjQURnTExvREt3M2JjT1VFQ0JjbjVEb0kvdzE0TTZKV2c0SURHODhCQ3c4L0xLdXBCWjFobGw0MWdXZ0dhYkp1ZzhPcTJ4WDV6NWdEN0FQQlNvTlB4Q0FyQUZaZHUwMk81QXVvRWphMFdQWnBSeEFhWTVFbkk2c1lqd2NIOXVVQXdGa0dEWWZCOFFrNlk2UDVWUkxXT254QXl3WU1aYVBmREFrYlgyVzlJKy9nZ1BqY3ZBMGFFNUVJT3V1Q3VZeGxHdzVNdHZQcWk2dkNmK1NKOVI5Ym4zZytPTkRFQVN4VktPRU1IR0Q3Rm5SMllGTXViWWxaUVlqUElyYW1kaUFlRXFoRzNGVlFjR0FqT1FCY2hVRkR1QWRoRy94ZkZZRDFvR3hsc3hWdTJlK21md2RuSTE5bVZHbzlITEJQN2RGNVFUOFR0NzhLUWhURXdMQnNrSlRYdlJ0RXJxS3VrV2R3b0pNRDE4ZzZNbnM0alBuQVYxZEI2Q2RZdzd6SGZsMlp4YjNnd0U1eWdHMk84bGsrY0Y4NytUYWk3SzNoQU9Ibk5uRFlMeTRvT0JBYzZPRUFYeFZnMExEOWJKaDVlNWdWdDRNRGNNQytBL1RPWUVkd0lEamc0d0N4K0t3MEIvdVNSNnJnUUhDQW1IMDJHQ0dHUDZqQ2dmOEJ5bkwySmkvR2VYRUFBQUFBU1VWT1JLNUNZSUk9XCIgLz5cbiAgICAgICAqIDwvZGl2PlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBgUShIKWAuXG4gICAgICAgKlxuICAgICAgICogKHNlZSBbUG9pc3NvbiBkaXN0cmlidXRpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BvaXNzb25fZGlzdHJpYnV0aW9uKSlcbiAgICAgICAqL1xuICAgICAgLy8gQ2FjaGUgZm9yIG1lbW9pemF0aW9uXG4gICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiX2NvbGxpc2lvbkNhY2hlXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFwcHJveE1heEJlZm9yZUNvbGxpc2lvblwiLCAocm91bmRzID0gdGhpcy5hdmFpbGFibGVVVUlEcyh0aGlzLnV1aWRMZW5ndGgpKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gcm91bmRzO1xuICAgICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLl9jb2xsaXNpb25DYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgICBpZiAoY2FjaGVkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IE51bWJlci5wYXJzZUZsb2F0KE1hdGguc3FydChNYXRoLlBJIC8gMiAqIHJvdW5kcykudG9GaXhlZCgyMCkpO1xuICAgICAgICB0aGlzLl9jb2xsaXNpb25DYWNoZS5zZXQoY2FjaGVLZXksIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogQ2FsY3VsYXRlcyBwcm9iYWJpbGl0eSBvZiBnZW5lcmF0aW5nIGR1cGxpY2F0ZSBVVUlEcyAoYSBjb2xsaXNpb24pIGluIGFcbiAgICAgICAqIGdpdmVuIG51bWJlciBvZiBVVUlEIGdlbmVyYXRpb24gcm91bmRzLlxuICAgICAgICpcbiAgICAgICAqIEdpdmVuIHRoYXQ6XG4gICAgICAgKlxuICAgICAgICogLSBgcmAgaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWVzIHRoYXQgYHJhbmRvbVVVSUQoKWAgd2lsbCBiZSBjYWxsZWQsXG4gICAgICAgKiBvciBiZXR0ZXIgc2FpZCB0aGUgbnVtYmVyIG9mIF9yb3VuZHNfXG4gICAgICAgKiAtIGBIYCBpcyB0aGUgdG90YWwgbnVtYmVyIG9mIHBvc3NpYmxlIFVVSURzLCBvciBpbiB0ZXJtcyBvZiB0aGlzIGxpYnJhcnksXG4gICAgICAgKiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgYGF2YWlsYWJsZVVVSURzKClgXG4gICAgICAgKlxuICAgICAgICogVGhlbiB0aGUgcHJvYmFiaWxpdHkgb2YgY29sbGlzaW9uIGBwKHI7IEgpYCBjYW4gYmUgYXBwcm94aW1hdGVkIGFzIHRoZSByZXN1bHRcbiAgICAgICAqIG9mIGRpdmlkaW5nIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgcHJvZHVjdCBvZiBoYWxmIG9mIHBpIHRpbWVzIGByYCBieSBgSGA6XG4gICAgICAgKlxuICAgICAgICogPGRpdiBzdHlsZT1cImJhY2tncm91bmQ6IHdoaXRlOyBwYWRkaW5nOiA1cHg7IGJvcmRlci1yYWRpdXM6IDVweDsgb3ZlcmZsb3c6IGhpZGRlbjtcIj5cbiAgICAgICAqICA8aW1nIHNyYz1cImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBTklBQUFCSkNBWUFBQUJJT0hqQ0FBQU8ra2xFUVZSNEFlMmRCZkRzeGczR3Z6SXpZOHFNYVZKTUdWTm1acGpTbEpuYnRDbWtrREl6VHhsU3hwU2JNak9uek14d3Y5ZlZHNDJmOXl6N3pnZC9Tek9lODltTDhwSzBuN1JTVW5KZ096bHdBMG1mbGZTT0RibTJrNHRaNmtsejRKaVNmaUhwdlpJTzNwQnIwaDhrSzcrZEhMaTdwRjlLT3RaMkZqOUxuUnhZUHdlT0l1a0hrdTYvL3FKa0NaSUQyOHVCMjBuNm5hVGpWNnB3WkVuWGszU0FwTWZPdWU1V2laK1Brd003bmdOSGt2Uk5TWStzMVBRWVJXNzZpNlR2U1BxTnBNUEwvYzhsY2ZHYzYxMlZOUEp4Y21ESGMrQW1rdjRzNlNTVm1yNUkwajBsSGJXOGY1MmtFNVg3KzBtNmRDVmVQazRPVElZRFI1RDBKVWxQcXRUNHVKSnU2ZDZ4OVB1WSsvOUdTYWQyLy9NMk9UQkpEbHh6cG1ENG02UlRCV3QvYTBrSHViQS9TaTJmNDBiZVRwWURoMGw2ZG8vYUh5cnBpaVU4bXI1L1N6cEZqL2daTkRtdzR6aHdCVW4va25UbVlNMzJLYk9YN1RPeHBQdXZwTDJEOFROWWNtQkhjb0RaNVdVOWF2WnFTZTl6NFU5WE90SmQzTE84VFE1TWlnTVhsdlFmU2VjSzFob1o2cCtTL0Q0UmF2TS9TZnBJTUEwNjNnc2t2Vm5TWTJiWDBVcThFOHcwZ28rZXpZeXZrUFNTc2tkbDc0SkpaN0Rrd0hvNDhIWkpiK2lSOVhuTGJOUlVrVDlFMHFNQzZiQ2hTd2NpUHZ0U2RNQW5TenFEcEVNa25idWtjYU9DOXlQZHBPVEFSblBnZkdVMjJuZUZwYnpLRE1kM1o1ZmZyOHJHN251Y3NnSlZQQjBNdWV0eExtemVKZ2Mya2dOc3FLNGFnWUFzZHNMQ0RaWnlkQmF1eXpZNGRHQlovbG5ZeHV2OG14ellEQTZjcmFpc0w3SEM0akRUdk1YbGgvcWNUdlJoOXl4dmt3TmJ4UUdFK1kvM0tQRU5pNElCSlVQMEFnRHJpWTUwZXZjQVRCOGRLZVVneDVTODNSNE9uRmJTUHlUdDM2UElyNUgwMVo3WGh6clMvMmpwU0JmdkNKZXZrd09qY2VBOGtzNDZNUFZuRmpOeVpvaDEwWEZLWndaSm5pcnVkWDJGaWVkNzA2TFZlczRBUHB4Y0VvMzN1Z1BpTGpQS2xjdHM5UDVsSnBwcEpRY2lIRGg2d2NOOXZUUkNUQjc2YXJXZUlPbHJNOE84STBZeUhERU1hdTJVajBaa2NDYmR6b0VUUzNxM0pFWnlVQWlnRVdpSTkyMFAzdm9VMjZFL1NycEY2OXZWUGtUUlFmbjNXMjIybWR2VU9ZQThjekxIQkxCdU5NVHZ6eXhhZ2VoRTZCR3pUdlE5U2FDMUZ5V01BTjlVMU5tZmsvVFdHVVRvY3NGRThWS0Vzb01aTmVXaklOTXkyRGdjdUVicFNIU21hd2V5d0RBUDAvQTdCc0oyQlhuZ3JCUGNad1lKQXU0RDBaR2ZYc29UY1pweXFSSVdORU5TY21DdEhFREd3VGNDSGVrRGdaTFF3SDlXOEcyQjROVWdaeXdPSTYwVFdVRCs0KzhCYzR5ejI4UEtMK2JxbEx2UHNyU1NWRDVPRGl6T2dYdVZCa21qQkV4YUk1UVVQNWxwK3U1ZEM5RGpPZWJtNU1lR2JwT2VGdXdnR0FCaVlidHh5N29MRmdSdHMySTcvVDlDTXg5a3FvVGZCSlFITk96bnpXRUNka0svbHNUZXphSjBzZUt1QzNtclNhYUplM0R6eFRiOHg1N2trNUlBQUU2TkVNQmZQbHY3MzNWcUZYZjFmVmJwU093Tm1VY2Y5M3FYWWdHRnhNUDh3NUh1QWNEU3FiRzQzU282VFZrbm4ybURTLzAyU1doMVB0MXlmVkVTYnB3OHZWalNGMXJDRXYvek13Y2JqL2VCeS9MZ1U1S3UxSGcrbGIvbmNLcndKaS9od1czSzVpM3E4ekVKT3lMOE5tRGN0MDdFUk84NklteWlpOS8wMGZqWXhXanJEbVcwWXNSNmFSRkkrYmpOalVGVW8zc1ZiNTZFNVVLMXlvYzZhVVhWQzF3R3ArK243TTNGblJFQjdSZDh3dFd3VndLZ1RmdkdDbXg2OEhOSEIvcXVzeW5hR3M3ZXZtaEpQT00ydWZDZ2g2MWpZQTNaUmFZaUpjNUZ1d0lYR1lGbDNoVHA2bzYzMTNFTWdPZC9YY0VBZzN6MjVXMzBhNGZRaUdVaG1LdHRJVnZMTTJwRzZPR2xjU0JNUnpZUThRT0FMNEVwSW9tWjFiOWQrUFhCd2x5V1Y1eHZ4UDdPbUlRcEJPYnE3Rk50SGJHY1F3dURXbk5iQ0h3WHN3dHVieU5FZ3lBOEIxMUZpUS9LTW5DS1pIc3o4QXhWT0xNVTZBRUdtTEVJbVF3bkpuNVZoSW1HbnhYSHludmhkQmxwV1BjT1FmNHVuUG5BQkpCdERCdm0zZDdXa21PQVlFbENvMmdUb0d2eGJsdzJCS1BlUW12cGJPTnpab1RmRjU0OVh4SzJQdEZCYTBoOUdjd3hCMjhxRnRpUzREdHNQRjJnTUF1SXlMYVFsNDhpSXlUTzJPbEVYQmZxVVVtVUYyaU9JakNWU0xKZzI4Q1VzUU4vczZJMGljVHpZVWpEVzRYNmQ4dStmMGJoR2VnQytJQTUrUmlFZlA3ak1wZ3pvTnVGR3kxY0Y1OS9qRXliYWVLQ3FEWmlzaGZFdTJZdjkyazhxSXp1eC9NUDU5d3pHNUJuazlDME1BMnZZbmNaVjdoMGlxaDh4R1lmNGFQeWthOGJLbkx2dk5DL2k5Nmo3Y0svR3I2d3JVUHp5NnpLWHNrNW93a1ZiTnN5RUFXUkxNL2labjRzV3NjZy9DelFTVDFmL0QzdjJ0cmJVc3RDSWZEYS85emkrWitLUS93eURUT2kwTHN4NmNWdFVSdUJxd0pqMVVVSW9FengySit3WDJOMjhYUWdCRVM4dVRBMXYyckcvSWUySk1hb1FsNW9aQ0xDZmtzU3V4K1ovVXgwcVlHSk1oOEhtYWN2a1Flb1lqdDZwRzk4d2xObjhtZnZDaGdPQjJzQjlzVHJEcDBMMlFPK1JwQUNPUHU0K1pCQ0RJeERSNmN4anpVck1JQ2pkYTFka1JYSHdLcjlQeHE5RkhzU213RVluVm5ING9hSUtkRWpFMkI4VFFQRjJaN2VFMHV0VURpb29BRkF3R2hvR01EY1grdGNIN0dSeXhUTk8yWW5UNjh2ejNtSERjeFFBbGRGR2x3UitRZysyVXpRUno2eThqSDZrOWZRaG9TcW5hVVJTN28yQXJTSlFvTTg0QjNoYWlzSU5rT1I5Yno1UTF1YXkzeEd2YSsyekFRM0xTMk9XMmVkYmNUbUZVc0ZwdURtaU05bytuZEpUZWNSZUtma0F6SnpkUkhlTE8wRDIyWW9uZENiR0lQQklqMDBnR3ljZWpJdEVNY2dOanVaRDlkMTcrVWpHcDZkNkZiNy9XRXBFK1hxSXg5Wk9lQXpjWWRxamdCZTFzNElzano0dmFwVE9YOWlkbkxkYldjZVM4MlB3clVrdmJPVW8yMjI5K25rZlU4T01CT1lYRU9qWmRSanRFS0dhU01hSFZPMHhTR01LUnBzbWRZV2oyZU1TdmhVTm5wcSthZ3M0enlSTnAyc0pwU0NKbWk2cHZYeEkvY21Id0d4WjlidHVvQUEwUkgrMEZDclJ2SWlEUHRJeEdjZ0dFTE1OZ0F6STRSMmtZNEN6bzA4L2NYMzVZelZKbklqa202R21jTUJ2K3NPcUErbTE3eGNNcE9ZK3RjN043OWtpWGVQT2Zud2lzN2hHOE5oSmQ1Rk91S044UnBWUFhWRkxveVE3UjhOa1k5SW4wR0UvQ0orcU52S3d3emFWMWpHYndJeUZJTUd5M1EyazJ1RFUxdWUrV3dnQjlBSThiRWZVSW1QSU1kN0xxODZSUUhCc3p0VjRyVTlSaUJHM2hxaUFXdExyODh6THgvVlpBNmZudDgvR21yMFJRT0dSd2Y3aEJlOGJ5NTdGMHd1SEIzbjhvQis4NnF3akxNMytkaTFHZUw2NVQwZHdLTVhXSmNUenpzaHIyU3grN0hGNllNUTJCMTV3UnMyNWlndkYwajFMdkw3UjloWURTR3NNOGtQcmRvaWhNODRaaGVXbUtUSFFNUXN5UkdSZlFqQm4zMlhJWVRpNUNsNTdlTEJIdnhqZEVOOU9tK0dNTG5DY0ZPV2lEVTBWTEpSZW1KcENMWFpMNXJPa0hBczUyaUUzd3BHTm56ZFVQbUliR3hwdDRqOXplWGRhUWhnMlBDOXhrSEZ5RDNVQjdSMWRPbEdoL1puQ1FWWmtjRzZPR0NPdytmSlI2akcrV0ROSlJ3WUtwN1Q0S0lFY0pFNHRka3ZtczZRY0NnWXlIdWU5YVpQMStRamxqSkRLU3BIMXRJSEhmRmJTWlNsT1N0aXBtRWJ0V2hWVVNiTVcvWnhKQ1RnNGlIYXgxcjU4bm5oQU5vMEdsZHRoakN0MDA5YmhGN3dWSDBhSmxvNVJ0RjVzOTlZSDhiTFJ4R1VPdnRycG1BWktoOVJGdzZvZ2tkOWwyREdCN3pqWUhIYzNKS3c5L3h5MWlxZG5Yd09MeHV1ZmdtT3NnalFLQ3IrUEduQmMyNko5K1lZcjNrZWpHWEI3amtmeURaVDdibjlzaGRVbTgwc2pQMHVLaCt4K1RnVUhvOXlnWHB3UmZhaHZQMVJjeWF3K2tSKzZZVGtHVjE2TmRPRS8zNnZyZm5lL3dmdnlINGcrYkVjeGJpTlpaOXRjdU5ETGxKM24yYmVCemhnR2pRWWo0cTZTYVlXbjJkRHdraUlSNWdJbVRPS0lTTThLbmJLeVRKejN2S2xWZzdnU2NTUHdKbElBNW5HR3FTSDVkZlNyejNIK3BiVDN1Yk5LTFc0UE1jN1RnMEwyUllQVlRreUt6QXNrNkd3MWtWcjJOZWRjRnY2K2F5RkEvZ1ZvTEV3SzZGRnc2emFpRkVZQjM2b1BBMlJZTy84cjQyNExKMjZ5STdOR0RMQ2d3bWtyRnpSWlJJZGdNYURVZ1E1ZzdqSWFHalMybkJwTE9lUU81RGZETkdBb3c3OEVPQWhad2hocWJtSVRkSWlHNmdnVXZ3RytwRHlaNXdBQnhCT2FWd29DMEFwNFBJVmxBS2pLSjJMcFZnWGNlNG5hVVRrRGhvbldxY2hJenlZTXpyQloyWVFvc2l4Nzh4YWJMNmlZR2c2T2dHMHlzemt2Y3N3V0lEVVJxUFhEQTlvbC9COTdWbzRhUUhZMVRLOGlYWjloM3kvUmc2QXlhSVRNR0pEd1BWQmZ2ZjE4RUxqZm1WSlk5NFA2ZnBaYjE3WTJqc1FFa1AzUVdwcGp2WDhWZ1h3V29OZGpaWHZ0cWZMREE1aUhxVVVxeUs3a01lNW1scGlsdTBzbjRsallma2xMRnJLQ0JaME1NOU1Qa0p0dW1qalJyNEMzelYwK2RPbkVnQnRheVlkZmRKWlJkaERaNmJWdVBOS0dzWUJ6cE5sb09jNktMQ1NZZFBhd3Ird0FSNFlWb0pBTER0WXFZbm9Ea1RkSXdnQ0xocWhQZ2lIUFJJSlBtQVBxTTN4WURENnlvS0JTVVRZWittYk5Jd0R0blZBNTRqWUZSbEFnUEFyMnlzekRkcFFNR1dUTlp4QWdKcTFMOEN5bWM2OC84eDRUT1BiUU5oUGNhUmowbkFPWUZSS3AwQ2xIeUd6WkY0RWlSTEpaM2NZdEZQbVJXZVp2aFpZMjQ1cDd3SlVhWWpHYjNmRlYzUnptYkl4Nm8walY1VDFqc3JHa1BvczB5Smtsc3lMSUZFaStld0tnemJPZ0kvMGRteU1tRWt3QkZ1VWFEaGZtVm5NN3Ixb1FpM3hXU290Z2xkclNYS1VSOHlhREZJclcxcU1Vb3YxSitxUktKRVQvVmdKbVNVemFKRFJxYWxZUUJWTkIxaGt2OElYbWgxOGZGK0Q2NW9hc2VrS0lydUdBcGthUHhhcHIwZnE0eks2aTBEbU1ERnc3ZHNWZUZ2ZUErVTVZRnNLdThSeW9sSGNmNG5wVFRrcFErcEg1U01jNk5DSlZpWWZUZm5qWk4yM2h3T0cxSS9LUitBSzZVaUhiRThWczZUSmdYRTVBTGJRbG1sc3FYVDUxVUNlWWorVU9DdVJqOGF0ZnFhZUhGZ09CenhTSDJoVzF3VW8xenJlanBHUGxzUEtUR1hLSERDSG1HQWlJNFE4VGtmQzF6Z3d0NlRrUUhLZ0FJZnBHT3diUnNqMmoxSStpbkFydzB5Q0E1aXgyRElOaUZBWGVVOVBxL0pwM2xXbWZKOGNXRHNITU1leGpoUXhhQVJGWXVIM1dYdnBzd0RKZ1EzaGdGa3lBdytLa09IcmNHV2Q4bEdFWXhsbUVoeXdJek9qbm5BeFZXRkdXc1FLZVJLTXpVcE9od1BBeW15WjF0Y1Ric3BIMDJrbldkTU9EZ0N4c283VTF4TnV5a2Nkek0zWDArRUExc1IwSkRaZ0kyVDdSK0RyVWo2S2NDekQ3RmdPNEtFSmI3VDQ0Y0RuQWgwSmEydDgrZUdmbytrRkNlc0N2QU56V0IzK0dBalBlVnFjMnJIZkFIOGpPNWF4V2JIcGNBQURVdzZnNDNDN3RvdVRJTTB4ajNHRk03WGF3dktNOEJ5cU5qcjlEKzlZdVIxMWhTUkNBQUFBQUVsRlRrU3VRbUNDXCIgLz5cbiAgICAgICAqIDwvZGl2PlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBgcChyOyBIKWAuXG4gICAgICAgKlxuICAgICAgICogKHNlZSBbUG9pc3NvbiBkaXN0cmlidXRpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BvaXNzb25fZGlzdHJpYnV0aW9uKSlcbiAgICAgICAqXG4gICAgICAgKiAoVXNlZnVsIGlmIHlvdSBhcmUgd29uZGVyaW5nIF9cIklmIEkgdXNlIHRoaXMgbGliIGFuZCBleHBlY3QgdG8gcGVyZm9ybSBhdCBtb3N0XG4gICAgICAgKiBgcmAgcm91bmRzIG9mIFVVSUQgZ2VuZXJhdGlvbnMsIHdoYXQgaXMgdGhlIHByb2JhYmlsaXR5IHRoYXQgSSB3aWxsIGhpdCBhIGR1cGxpY2F0ZSBVVUlEP1wiXy4pXG4gICAgICAgKi9cbiAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb2xsaXNpb25Qcm9iYWJpbGl0eVwiLCAocm91bmRzID0gdGhpcy5hdmFpbGFibGVVVUlEcyh0aGlzLnV1aWRMZW5ndGgpLCB1dWlkTGVuZ3RoID0gdGhpcy51dWlkTGVuZ3RoKSA9PiB7XG4gICAgICAgIHJldHVybiBOdW1iZXIucGFyc2VGbG9hdChcbiAgICAgICAgICAodGhpcy5hcHByb3hNYXhCZWZvcmVDb2xsaXNpb24ocm91bmRzKSAvIHRoaXMuYXZhaWxhYmxlVVVJRHModXVpZExlbmd0aCkpLnRvRml4ZWQoMjApXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogQ2FsY3VsYXRlIGEgXCJ1bmlxdWVuZXNzXCIgc2NvcmUgKGZyb20gMCB0byAxKSBvZiBVVUlEcyBiYXNlZCBvbiBzaXplIG9mXG4gICAgICAgKiBkaWN0aW9uYXJ5IGFuZCBjaG9zZW4gVVVJRCBsZW5ndGguXG4gICAgICAgKlxuICAgICAgICogR2l2ZW4gdGhhdDpcbiAgICAgICAqXG4gICAgICAgKiAtIGBIYCBpcyB0aGUgdG90YWwgbnVtYmVyIG9mIHBvc3NpYmxlIFVVSURzLCBvciBpbiB0ZXJtcyBvZiB0aGlzIGxpYnJhcnksXG4gICAgICAgKiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgYGF2YWlsYWJsZVVVSURzKClgXG4gICAgICAgKiAtIGBRKEgpYCBpcyB0aGUgYXBwcm94aW1hdGUgbnVtYmVyIG9mIGhhc2hlcyBiZWZvcmUgZmlyc3QgY29sbGlzaW9uLFxuICAgICAgICogb3IgaW4gdGVybXMgb2YgdGhpcyBsaWJyYXJ5LCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgYGFwcHJveE1heEJlZm9yZUNvbGxpc2lvbigpYFxuICAgICAgICpcbiAgICAgICAqIFRoZW4gYHVuaXF1ZW5lc3NgIGNhbiBiZSBleHByZXNzZWQgYXMgdGhlIGFkZGl0aXZlIGludmVyc2Ugb2YgdGhlIHByb2JhYmlsaXR5IG9mXG4gICAgICAgKiBnZW5lcmF0aW5nIGEgXCJ3b3JkXCIgSSBoYWQgcHJldmlvdXNseSBnZW5lcmF0ZWQgKGEgZHVwbGljYXRlKSBhdCBhbnkgZ2l2ZW4gaXRlcmF0aW9uXG4gICAgICAgKiB1cCB0byB0aGUgdGhlIHRvdGFsIG51bWJlciBvZiBwb3NzaWJsZSBVVUlEcyBleHByZXNzZWQgYXMgdGhlIHF1b3RpZW5kIG9mIGBRKEgpYCBhbmQgYEhgOlxuICAgICAgICpcbiAgICAgICAqIDxkaXYgc3R5bGU9XCJiYWNrZ3JvdW5kOiB3aGl0ZTsgcGFkZGluZzogNXB4OyBib3JkZXItcmFkaXVzOiA1cHg7IG92ZXJmbG93OiBoaWRkZW47XCI+XG4gICAgICAgKiAgPGltZyBzcmM9XCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUljQUFBQkRDQVlBQUFDMm5oYW9BQUFKSzBsRVFWUjRBZTJkQit3OVJSSEh2eUNnWWdVVnhWaUNCUUlSRlJRRUZWRUVSVkdLZ2dZd0ppQWt4Q2dxRUNrUkpRcWlDUWpTWXNFWUN5ckZnZ1JEU3l3VXBTTi9paFhRSU5VQ0NpZ0s0dnZFbVdTNVhKbTk5LysvMzd0M084bmwzdHVkTFRjN3R6TTdNN3NuRlpnVkJWYVNkTGlrcldmVllFTTd4MHZhcUNHdkpBY284QmhKVzByYVY5SVJrZzZWOUI1SmF3ZktOcUdjS09salRaa3pUSCthcEVzbHZYS0diUzVFVTgrVDlGbEp2NVowaktRM1MzcVpwTmRKK3Jpa3V5U2RJZWtGbVUvN1lVbmZDNVo1aXFSZjJYV0ZwUFQ2cGFUZlM5b3FxZXV4a3E2elBxZTQvTDdHOExkUDhQbTVucVRmU0hwV0piMzhyYUhBS3BMMmwzU1B6UlJQcmNFaDZlbjIxdjNGR0tZQjdWSEptMHE2VTlJekg1WGEvdWR4a3A0dkNSSHdpRjBmbExTV3BOVnJpc0lnTVBabkV2eURiUENmVUlOUDBuNlQyZkhIa2hCM0JSb29zT1pFRDdoSTB0OGt2YjRCSjAxbWtQOHNDUVpaSjgybytiMnlNZE1CTlhtUnBCTnNzUDhZUVpaMHBPSFROMFJqRzZ4cXM4cHViVWhqem51T3BPc2wzU2VKTnp3SzZBNjgwVjJpWWc4VFJYVnZlNlN0WmRiTzF5TElraTR4L084SDhmZVI5Q2RKVHd6aWp3YnR5Wkp1TkdLK0svT3BYMnpsL2l2cGhTMWwwUkdPYnNsdnkzckdSTStoZnBod3p6WkV5Mk9BLzIzNEh3cmdnMEtadjB1Q1NRb1lCWkN6dkYwUS90czlxRUo1eEJEbDM5OVFIcVdSL0kwYjhydVNkN2J5MUJGUmdMZE44Rkdpby9BdFNaZEZrY2VBeDVzQzBYblRJb1N2b3drckd1cjRZbDNtUkJuOHd1U052R01LaFM5WDMzQmxGSDBEWFNjSzc3WG5lRW0wd0NMalBja0dqWUhGOXRBWGJqR2lOdWtkNVBlWmxidy9MRS9wWTFUZitFVkhmN3plNnAxVkR1MnczQjQ5WUsrQUdGenI5NlFHWXVWZlZzZHBOWFc0VHNKeXNnL2s2aHN3Zks2K2tmYnJia21ucHdsai9NMmczbXlEaXJMWUZ6QWVPWU14L1ZkaFI4dC9lelVqK0grWHBQNkkySHRyZ3AramIzaDNmalpSZXFQTFpTK3pjSGRNeGo2b21NVDd3blpKUFhVSzZjR1czOWVINGZvR2ZmMXI0THJmMnNQK2txTnYrUE9mTW5FUlBDeHBOVThZNC8wVHlhQytjUW9DWUdKM0pxc1RUVDY0ZlgweDJGNm8vOHZCUHY3YzhMOGJ4SytpSFdYbDI1YmwxVElMOXgrNUN0RjVTL0JoOUFWOEg5U0RuUVJSVlFXVVNQS3hwZVFDSm5LM2IrRHM2NExVdm9HanNBOGNadjE5UlovQ2kxTG1KMGFFMjZkNElFUUZBOC8xZ1laNmNNNlJqODhqRnpESWVmMnNKTG9BNTZEanY3UUx1U0gvUUtzREIrTm9BVWNUaEx4MkNncDgzZXE0dGNYczdETVVEclJjWUhsTkgvRytSdURUaHA5cjMwanJQc1RxMkR4TkhOdHZscDBRSGh0Q0gzaFJzbVRjdGFVQ0Z5dHJ0T0EwWmJtKzhaVW1oRXE2KzFQNjZodFU5MG1qeTZnTllUNTlZdnJPQlhTTEM0eUkzMm5RTmJ6T3p4a2VidmNjU1BVTkxKZGRnRVB2UVdzTGwzNWZPTmJxaUlpeHZtM01mVG5lREZmMm1BVlN3UDNPNmdCZkE2dU5xcWNTL1lKWjV5cEpUVEVTWGg4REJlNXJQQ0Y0ZjdlVm8yeUVzZDZVNEc4WWJLTU9EVEg0ejRDYnY2N3NRcVdkWlFSbEtuVjR0a1Y0dVJoWTE0SitQSCtuU1lqZlE1SXV0NEFmVDIrNnY4WGFhQk05ZFdWUHNuSVk2aUpBQ0NPTTFOZSs0VzBRTmppTlVkRHJHZnlkTnhKaWNya2RBakh3M01xVFlSZ0M5cmEzQ3BrZVhab1NRTVJ5bWVDYkhQQWxjdFNmY3JFeFI1Ti9KOUkyUmpQaVdhSnRSdW9jTk02cnpQbDJ0WVhYc1FLcEFsUHREd3lQb0oxYzRFMDh0Nk1RQXdOVFl2SjJmWWlaZ0xaZlhlTXhCaC94dDlra0VnM1I1U0x5YkJOaEdMSHE3QzV0M2RqQUdLeEVoQ1ZVWXRaQXh5Qm8rSGNXWVU1TXhQdHNjSkRCdlBsMVVWd01YQmZnUXNlczNiYWNmYmxGYjUwL0dkeTZpNVVJU3FvRDRvNjBPbHpTeUl2b0tsNGZkNWdNa1VsOGJCYkFxWmljSTVwelZzVnpoSXh5Q1ZQc1pVWXRqRkFNQW5LNHpuR0dJa3RrZWhkUUIyODIrc2M4d3ptVGdLUWY1blNRNk92ZFRRRmpta3VWdDV4NmhvejdXNXROMG1jZ1N2MUhralpKRTF0K1kzUmoyVHV2UUF3dHM4WTJrUTUrMWFLcWI3TGxuQWVRakpFNVVGai9rQ2lxeUhwV090QWtDcTgxWlpiVjBEd0MxdFVybzNvS1FTT3AyOVo5QkdOa0RoaURXWk0zQzE4TXZ4RVR1ZjZIYjlyK2szbGpEZ0tLN2pYbHRsZmZ4c3djN2tPQktmejZhQThxb3ZqaWgwSDVuQ2ZnK2RnMDFSdkd6QndNS2t2RTJ5YmJENG1VMnFFM0ZhVXRiRnRqbDJWMWlpYXlpcjdEbmltVkVsa1ZnRHhtNXNnbVZrY0JGSHdNYWF3QWx4TFlLbkZobjZWcnRkT0ZPYW9VbWU0L3NSZnMzbDlLUURRMjdRWE82bGRoaml4eWpRdTVNTWU0eGp2cmFRdHpaSkZyWE1pRk9jWTEzbGxQdTd5WUF4YzJmZ28yNjB4NzlkbTB3N0tVNVZ1NTRqVG8zQUMrdkpnRFp4WmI3aUliZExwd3pzdGk3Lzhqc3lQc0grWEtvZ0dCUjYyd3ZKaWp0WkdTT1V3S0ZPWVk1cmpOcE5lRk9XWkM1bUUyVXBoam1PTTJrMTdqQzhBaithbVp0RllhR1F3RkNGUWxFQVRtK01aZ2VsMDZ1c0lvd0s1dUlwOEpWdVV3RDQ5ajRIN0RKQ0thWlNSYkN0K3d3bnBRS3A1YkNuQmNFZWR4c2hXLzZTSXNmbDdEM3VhUnNOQ1VzOEdJZE9kd3VmVDYwdVRvcVZNcjlHU3JBcnZ1VHE3Z2VqbGV6c2hwUC9OSWk5S25DZ1hZMnNDeGs4ektIcE5MdUNHNzFkNDIyWDlMbkNtQnl3NXNaV0JtSnY3RGo0eGc1dVk4VTZ6TUJBNU5GYVRqRFpYN2ZGSGdUQlBWYkh1SUFQR25MdElqK0FWbm9CUkF3Y2VGd0dBemEwVEFqN004TG9KY2NJWkxBUnlHTUFZWHUrTzdBTDNDOGQvWmhWenloMDBCemlObnNQOHowUi9ZQXRJRmJNc0VILzBrM1JMWlZhN2tENUFDZnRZNk8rTWpnRzBKNXBqbWlLcElPd1ZuaVNsQXhEazc2QmpzcUw3aG02cUt2ckhFZzdlaW0yZERFNHpCRmRFMzJLenQrRVhmV05HanM4VDFjK2c4Z3gzVk56Z3dCbnowamV5akVaYjRXVXZ6bVJSd2ZlT0Jsck0xMGpNM1hLUVVmU09UMEVORFI5L2dqRkJtQXM0WWJYSkxwT21PWC9TTm9ZMTJabi9URTQ4akRrdU9ibko5ZzREb0FndE1nWS9ZWVBOOWxzY0huak8xYnhSOUkwQ3dJYU80UCtXbndZZndveC9LMFk5QmdnMFZEWDJEclJhSWllZ0JPSzZNZm42b0QxMzZIYU1BRzROY2Y0aDgzeVgxcHhSOUkwYmp3V0x4U1hDWWcvUEo2NDZzckQ0WTM0OEZ2OWczcXBSWndQOGM0Y2hnYzFoS0JQeHJDMFhmaUZCcndEaDhTOTQvVEh4NDhEbEsvRWFRVUVOR1F4RjFFemd6QjE5Y0lLMEpDQk5NdjlERUJ3UmhyZ0lMUkFFK2ljRlhxTG1xRzhJNWZINVo1Vm41eW1RVnovK0R6MEc1cTFiS3pPenYvd0F2ektobmh5RU1mUUFBQUFCSlJVNUVya0pnZ2c9PVwiIC8+XG4gICAgICAgKiA8L2Rpdj5cbiAgICAgICAqXG4gICAgICAgKiAoVXNlZnVsIGlmIHlvdSBuZWVkIGEgdmFsdWUgdG8gcmF0ZSB0aGUgXCJxdWFsaXR5XCIgb2YgdGhlIGNvbWJpbmF0aW9uIG9mIGdpdmVuIGRpY3Rpb25hcnlcbiAgICAgICAqIGFuZCBVVUlEIGxlbmd0aC4gVGhlIGNsb3NlciB0byAxLCBoaWdoZXIgdGhlIHVuaXF1ZW5lc3MgYW5kIHRodXMgYmV0dGVyIHRoZSBxdWFsaXR5LilcbiAgICAgICAqL1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVuaXF1ZW5lc3NcIiwgKHJvdW5kcyA9IHRoaXMuYXZhaWxhYmxlVVVJRHModGhpcy51dWlkTGVuZ3RoKSkgPT4ge1xuICAgICAgICBjb25zdCBzY29yZSA9IE51bWJlci5wYXJzZUZsb2F0KFxuICAgICAgICAgICgxIC0gdGhpcy5hcHByb3hNYXhCZWZvcmVDb2xsaXNpb24ocm91bmRzKSAvIHJvdW5kcykudG9GaXhlZCgyMClcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHNjb3JlID4gMSA/IDEgOiBzY29yZSA8IDAgPyAwIDogc2NvcmU7XG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJuIHRoZSB2ZXJzaW9uIG9mIHRoaXMgbW9kdWxlLlxuICAgICAgICovXG4gICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0VmVyc2lvblwiLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlcnNpb247XG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogR2VuZXJhdGVzIGEgVVVJRCB3aXRoIGEgdGltZXN0YW1wIHRoYXQgY2FuIGJlIGV4dHJhY3RlZCB1c2luZyBgdWlkLnBhcnNlU3RhbXAoc3RhbXBTdHJpbmcpO2AuXG4gICAgICAgKlxuICAgICAgICogYGBganNcbiAgICAgICAqICBjb25zdCB1aWRXaXRoVGltZXN0YW1wID0gdWlkLnN0YW1wKDMyKTtcbiAgICAgICAqICBjb25zb2xlLmxvZyh1aWRXaXRoVGltZXN0YW1wKTtcbiAgICAgICAqICAvLyBHRGE2MDhmOTczYVJDSExYUVlQVGJLRGJqRGVWc1NiM1xuICAgICAgICpcbiAgICAgICAqICBjb25zb2xlLmxvZyh1aWQucGFyc2VTdGFtcCh1aWRXaXRoVGltZXN0YW1wKSk7XG4gICAgICAgKiAgLy8gMjAyMS0wNS0wM1QwNjoyNDo1OC4wMDBaXG4gICAgICAgKiAgYGBgXG4gICAgICAgKi9cbiAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdGFtcFwiLCAoZmluYWxMZW5ndGgsIGRhdGUpID0+IHtcbiAgICAgICAgY29uc3QgaGV4U3RhbXAgPSBNYXRoLmZsb29yKCsoZGF0ZSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkgLyAxZTMpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKHR5cGVvZiBmaW5hbExlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBmaW5hbExlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBoZXhTdGFtcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZpbmFsTGVuZ3RoICE9PSBcIm51bWJlclwiIHx8IGZpbmFsTGVuZ3RoIDwgMTApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIFwiUGFyYW0gZmluYWxMZW5ndGggbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMTAsXCIsXG4gICAgICAgICAgICAgIFwib3IgMCBpZiB5b3Ugd2FudCB0aGUgcmF3IGhleGFkZWNpbWFsIHRpbWVzdGFtcFwiXG4gICAgICAgICAgICBdLmpvaW4oXCJcXG5cIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkTGVuZ3RoID0gZmluYWxMZW5ndGggLSA5O1xuICAgICAgICBjb25zdCBybmRJZHggPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAoaWRMZW5ndGggPiAxNSA/IDE1IDogaWRMZW5ndGgpKTtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLnJhbmRvbVVVSUQoaWRMZW5ndGgpO1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoaWQuc3Vic3RyaW5nKDAsIHJuZElkeCkpLmNvbmNhdChoZXhTdGFtcCkuY29uY2F0KGlkLnN1YnN0cmluZyhybmRJZHgpKS5jb25jYXQocm5kSWR4LnRvU3RyaW5nKDE2KSk7XG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogRXh0cmFjdHMgdGhlIGRhdGUgZW1iZWRlZCBpbiBhIFVVSUQgZ2VuZXJhdGVkIHVzaW5nIHRoZSBgdWlkLnN0YW1wKGZpbmFsTGVuZ3RoKTtgIG1ldGhvZC5cbiAgICAgICAqXG4gICAgICAgKiBgYGBqc1xuICAgICAgICogIGNvbnN0IHVpZFdpdGhUaW1lc3RhbXAgPSB1aWQuc3RhbXAoMzIpO1xuICAgICAgICogIGNvbnNvbGUubG9nKHVpZFdpdGhUaW1lc3RhbXApO1xuICAgICAgICogIC8vIEdEYTYwOGY5NzNhUkNITFhRWVBUYktEYmpEZVZzU2IzXG4gICAgICAgKlxuICAgICAgICogIGNvbnNvbGUubG9nKHVpZC5wYXJzZVN0YW1wKHVpZFdpdGhUaW1lc3RhbXApKTtcbiAgICAgICAqICAvLyAyMDIxLTA1LTAzVDA2OjI0OjU4LjAwMFpcbiAgICAgICAqICBgYGBcbiAgICAgICAqL1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBhcnNlU3RhbXBcIiwgKHN1aWQsIGZvcm1hdCkgPT4ge1xuICAgICAgICBpZiAoZm9ybWF0ICYmICEvdDB8dFsxLTldXFxkezEsfS8udGVzdChmb3JtYXQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGV4dHJhY3QgZGF0ZSBmcm9tIGEgZm9ybWF0ZWQgVVVJRCB3aXRoIG5vIHRpbWVzdGFtcCBpbiB0aGUgZm9ybWF0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YW1wID0gZm9ybWF0ID8gZm9ybWF0LnJlcGxhY2UoL1xcJFtyc11cXGR7MCx9fFxcJHQwfFxcJHRbMS05XVxcZHsxLH0vZywgKG0pID0+IHtcbiAgICAgICAgICBjb25zdCBmbk1hcCA9IHtcbiAgICAgICAgICAgICRyOiAobGVuMikgPT4gWy4uLkFycmF5KGxlbjIpXS5tYXAoKCkgPT4gXCJyXCIpLmpvaW4oXCJcIiksXG4gICAgICAgICAgICAkczogKGxlbjIpID0+IFsuLi5BcnJheShsZW4yKV0ubWFwKCgpID0+IFwic1wiKS5qb2luKFwiXCIpLFxuICAgICAgICAgICAgJHQ6IChsZW4yKSA9PiBbLi4uQXJyYXkobGVuMildLm1hcCgoKSA9PiBcInRcIikuam9pbihcIlwiKVxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgZm4gPSBtLnNsaWNlKDAsIDIpO1xuICAgICAgICAgIGNvbnN0IGxlbiA9IE51bWJlci5wYXJzZUludChtLnNsaWNlKDIpLCAxMCk7XG4gICAgICAgICAgcmV0dXJuIGZuTWFwW2ZuXShsZW4pO1xuICAgICAgICB9KS5yZXBsYWNlKC9eKC4qPykodHs4LH0pKC4qKSQvZywgKF9tLCBwMSwgcDIpID0+IHtcbiAgICAgICAgICByZXR1cm4gc3VpZC5zdWJzdHJpbmcocDEubGVuZ3RoLCBwMS5sZW5ndGggKyBwMi5sZW5ndGgpO1xuICAgICAgICB9KSA6IHN1aWQ7XG4gICAgICAgIGlmIChzdGFtcC5sZW5ndGggPT09IDgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUoTnVtYmVyLnBhcnNlSW50KHN0YW1wLCAxNikgKiAxZTMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFtcC5sZW5ndGggPCAxMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YW1wIGxlbmd0aCBpbnZhbGlkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJuZElkeCA9IE51bWJlci5wYXJzZUludChzdGFtcC5zdWJzdHJpbmcoc3RhbXAubGVuZ3RoIC0gMSksIDE2KTtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlci5wYXJzZUludChzdGFtcC5zdWJzdHJpbmcocm5kSWR4LCBybmRJZHggKyA4KSwgMTYpICogMWUzKTtcbiAgICAgIH0pO1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgdGhlIGNvdW50ZXIgdG8gYSBzcGVjaWZpYyB2YWx1ZS5cbiAgICAgICAqL1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNldENvdW50ZXJcIiwgKGNvdW50ZXIpID0+IHtcbiAgICAgICAgdGhpcy5jb3VudGVyID0gY291bnRlcjtcbiAgICAgIH0pO1xuICAgICAgLyoqXG4gICAgICAgKiBWYWxpZGF0ZSBnaXZlbiBVSUQgY29udGFpbnMgb25seSBjaGFyYWN0ZXJzIGZyb20gdGhlIGluc3RhbmNlZCBkaWN0aW9uYXJ5IG9yIG9wdGlvbmFsbHkgcHJvdmlkZWQgZGljdGlvbmFyeS5cbiAgICAgICAqL1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInZhbGlkYXRlXCIsICh1aWQsIGRpY3Rpb25hcnkpID0+IHtcbiAgICAgICAgY29uc3QgZmluYWxEaWN0aW9uYXJ5ID0gZGljdGlvbmFyeSA/IHRoaXMuX25vcm1hbGl6ZURpY3Rpb25hcnkoZGljdGlvbmFyeSkgOiB0aGlzLmRpY3Q7XG4gICAgICAgIHJldHVybiB1aWQuc3BsaXQoXCJcIikuZXZlcnkoKGMpID0+IGZpbmFsRGljdGlvbmFyeS5pbmNsdWRlcyhjKSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgREVGQVVMVF9PUFRJT05TKSwgYXJnT3B0aW9ucyk7XG4gICAgICB0aGlzLmNvdW50ZXIgPSAwO1xuICAgICAgdGhpcy5kZWJ1ZyA9IGZhbHNlO1xuICAgICAgdGhpcy5kaWN0ID0gW107XG4gICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgY29uc3QgeyBkaWN0aW9uYXJ5LCBzaHVmZmxlLCBsZW5ndGgsIGNvdW50ZXIgfSA9IG9wdGlvbnM7XG4gICAgICB0aGlzLnV1aWRMZW5ndGggPSBsZW5ndGg7XG4gICAgICB0aGlzLnNldERpY3Rpb25hcnkoZGljdGlvbmFyeSwgc2h1ZmZsZSk7XG4gICAgICB0aGlzLnNldENvdW50ZXIoY291bnRlcik7XG4gICAgICB0aGlzLmRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcbiAgICAgIHRoaXMubG9nKHRoaXMuZGljdCk7XG4gICAgICB0aGlzLmxvZyhcbiAgICAgICAgXCJHZW5lcmF0b3IgaW5zdGFudGlhdGVkIHdpdGggRGljdGlvbmFyeSBTaXplIFwiLmNvbmNhdCh0aGlzLmRpY3RMZW5ndGgsIFwiIGFuZCBjb3VudGVyIHNldCB0byBcIikuY29uY2F0KHRoaXMuY291bnRlcilcbiAgICAgICk7XG4gICAgICB0aGlzLmxvZyA9IHRoaXMubG9nLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLnNldERpY3Rpb25hcnkgPSB0aGlzLnNldERpY3Rpb25hcnkuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuc2V0Q291bnRlciA9IHRoaXMuc2V0Q291bnRlci5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5zZXEgPSB0aGlzLnNlcS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5zZXF1ZW50aWFsVVVJRCA9IHRoaXMuc2VxdWVudGlhbFVVSUQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMucm5kID0gdGhpcy5ybmQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMucmFuZG9tVVVJRCA9IHRoaXMucmFuZG9tVVVJRC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5mbXQgPSB0aGlzLmZtdC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5mb3JtYXR0ZWRVVUlEID0gdGhpcy5mb3JtYXR0ZWRVVUlELmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmF2YWlsYWJsZVVVSURzID0gdGhpcy5hdmFpbGFibGVVVUlEcy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5hcHByb3hNYXhCZWZvcmVDb2xsaXNpb24gPSB0aGlzLmFwcHJveE1heEJlZm9yZUNvbGxpc2lvbi5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5jb2xsaXNpb25Qcm9iYWJpbGl0eSA9IHRoaXMuY29sbGlzaW9uUHJvYmFiaWxpdHkuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMudW5pcXVlbmVzcyA9IHRoaXMudW5pcXVlbmVzcy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5nZXRWZXJzaW9uID0gdGhpcy5nZXRWZXJzaW9uLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLnN0YW1wID0gdGhpcy5zdGFtcC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5wYXJzZVN0YW1wID0gdGhpcy5wYXJzZVN0YW1wLmJpbmQodGhpcyk7XG4gICAgfVxuICB9O1xuICAvKiogQGhpZGRlbiAqL1xuICBfX3B1YmxpY0ZpZWxkKF9TaG9ydFVuaXF1ZUlkLCBcImRlZmF1bHRcIiwgX1Nob3J0VW5pcXVlSWQpO1xuICB2YXIgU2hvcnRVbmlxdWVJZCA9IF9TaG9ydFVuaXF1ZUlkO1xuICByZXR1cm4gX190b0NvbW1vbkpTKGluZGV4X2V4cG9ydHMpO1xufSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNob3J0LXVuaXF1ZS1pZC5qcy5tYXBcbid1bmRlZmluZWQnIT10eXBlb2YgbW9kdWxlJiYobW9kdWxlLmV4cG9ydHM9U2hvcnRVbmlxdWVJZC5kZWZhdWx0KSwndW5kZWZpbmVkJyE9dHlwZW9mIHdpbmRvdyYmKFNob3J0VW5pcXVlSWQ9U2hvcnRVbmlxdWVJZC5kZWZhdWx0KTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/short-unique-id/dist/short-unique-id.js\n");

/***/ })

};
;